####  烫嘴面筋

#### vivo

1. 并发
2. 项目里的点：Springboot和SpringMVC区别；Drools
3. java基础题：Hashmap
4. 计算机网络和操作系统
5. Git：版本回退/分支/合并



#### TPLink

1. 为什么要投tplink
2. 进程；死锁
3. TCP和UDP；TCP如何实现可靠传输；浏览器输入url客户端网页显示的过程；TCP三次握手
4. 二分查找，手写
5. 怎么实现多线程；**线程池怎么实现的，有哪几种**
6. socket网络编程
7. static关键字；final的作用；
8. 介绍完全二叉树：按照层次顺序编号，节点i的左节点2i，右节点2i+1
9. 怎么判断链表有环
10. 二叉搜索树的应用场景：哈夫曼编码
11. **关于微服务化的基本理解**：微服务是一种架构风格，意思就是一个大型的复杂应用由一个或多个微服务组成。系统中各个微服务可以被独立部署，各个微服务之间是松耦合的，每个微服务仅关注自身的小任务。每个微服务运行在自己的进程中，开发和发布都没有依赖。通过一些轻量级的交互机制来通信，如http，可以独立扩展伸缩。
12. **spring的bean加载机制**；spring在构造上下文的时候就把单例bean都创建完成了，比如说classpathxmlapplicationcontext加载了xml配置文件，将其中的bean配置信息解析，放在一个beandefinitionmap中，在一些前序步骤都完成了之后，比如说某个bean的依赖已经加载完成了，这个bean的单例被创建然后放在singletonobjects中，这个singletonobjects是一个concurrenthashmap。然后上下文调用getbean方法的时候就能获取某个bean了。
13. cookie和session的生命周期；cookie如果设定了过期时间，就按照时间来；否则关闭浏览器cookie就会失效；session也有设定有效时间，超过有效时间来就会失效；session也可以在服务端主动销毁；
14. 如何逆序打印链表/ 如何反转链表：先问有没有空间复杂度的限制？没有用栈，有的话递归
15. 数据库事务的概念；事务就是逻辑上一组操作，这组操作要么要都成功，要么全都失败，他们是一个整体。 **分布式事务是啥**：用了微服务分布式之后会产生的分布式数据库数据一致问题。
16. **单例模式**：
17. **管道：有名 / 无名管道？**：管道是线程间通信的一种方式，通信的媒介是内存。
18. 快排，快排为什么不稳定
19. 如何连接数据库：springboot里连接数据库，配置数据库连接池hikaricp，在property文件中配置一下。
20. SQL插入：INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)
21. java多态的体现：3个条件
22. 如何确定无符号数的二进制中1的个数。。。。（n&n-1）
23. 100盏灯：什么数的因数的个数是奇数个？**完全平方数**
24. 生成1000个1000以内的随机数，去重排序
25. 找出一个字符串所有连续子串中字典排序最大的子串
26. 笔试，最长递增子串的思路，动态规划；笔试做的怎么样，有哪道题有问题：
27. 赛马：选前三快，前五快
28. 滑动窗口算法题
29. 反问：业务使用的哪种语言；如果入职了会有人带吗



#### 招商银行

##### 电话面：略

##### 视频面

1. 手撕：两个升序双向链表合并成一个降序双向链表：头插
2. 项目介绍 springboot aop原理 拦截器原理 jpa spring官网看过吗 撕一个代码：阻塞队列
3. **面向对象**的三个特性
4. 然后设计出一个**银行存款的对象间关系**，并说明为什么这么设计（基金账户，理财账户等等）
5. GC介绍一下（吧啦吧啦，理论很完美，然后问我有没有动手去调优过这部分，又被喷了，只会理论）
6. 为什么java中有GBK跟UTF8这样不同的编码？数据库里的编码到java中再到应用程序这整个流程里，如何去实现编解码
7. 线程间资源如何共享，如何并发
8. AQS的阻塞队列怎么设计的，画图给他
9. Array里的阻塞队列用过哪些，什么时候用的（在缓存设计里用过）
10. 写个题，很简单，最大的K个数，问时间复杂度，为什么用优先级队列写？优先级队列是什么（堆）
11. 给个游戏场景，如何设计各种对象，策略模式，如何切换策略，画出类图
12. 还有些忘记了，问他感受，理论很好，项目很多，简历好看，但是给出的设计的场景的东西考虑得太浅了，在系统设计这块要加强



1.  进程和线程

2. 类加载双亲委托模型：启动类加载器

3.  windows运行java程序（jar包之类的，没有。。）

4.  微服务、MVC（没用过啊。。。）

5.  Spring你觉得最大的优势在哪（还好没细问，学习视频我也就看了前面一点）

6.  java在操作系统如何运行

7. 讲讲TCP和HTTP

8.  get和post

9. 数据库引擎有哪一些

10. 主键索引、复合索引、最左侧原则的底层原理

11. B+树

12. 手撕SQL： 给学生表、成绩表。。。
     问题：查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩

    > Select b.id, b.studentname,  a from student as b join (select studentid, AVG(SCORE) as a from student_score group by studentid having a > 60 ) c on b.id = c.

13. mybatis#和\$的区别 : `${column}` 会被直接替换，拼在sql语句上，不安全；常用于代替表名和字段名；

    而 `#{value}` 是一种预编译的方式，会使用 `?` 预处理；常用于处理参数。

14. mybatis executor

15. JVM参数调优，gc方面：知道几个参数，比如xms，xmx，metaspacesize，maxmetaspacesize，还有设置最大年龄的maxtenuringthreshold。但是没有在自己的项目里实践过

16. gc满了怎么回收：垃圾收集器现在大多数采用分代收集算法，主要是将堆氛围老年代和新生代，新生代中用的基本是复制算法，分成3个区域，eden和suvivor；老年代通常采用标记整理算法

17. 多态业务上的应用：组合模式，比如说要医院的三级转诊模型中实现集体通知，可以抽象出一个组件，它拥有一个抽象的通知方法，县级医院或者卫生院就属于简单组件，它的通知方法中负责对接收到的消息作出反应，他们的上级医院作为复合组件，在自身对通知作出反应之后，还需要通知其下的所有子组件即附属医院。

18. 抽象类和接口的区别

19. 页面提交数据到数据库的过程

20. 分页逻辑： 继承PagingAndSortingRepository，使用pageable和Sort进行分页和排序

21. 配置的注解

22. 自动装配过程：Autowired默认使用byType来自动装配，如果存在类型的多个实例就尝试使用byName匹配，如果通过byName也确定不了，可以通过Primary和Priority注解来确定。

    @SpringBootApplication注解包含了开启自动装配功能，包扫描，SpringFactoriesLoader来加载META-INF/spring.factoires文件里所有配置的EnableAutoConfgruation，它会经过exclude和filter等操作，最终确定要装配的类

23. 接口的方法拆分的设计

24. 手撕：最长路径



##### 视频二面

**基础**

1. Java异常，Error是什么

   Throable包括了error和exception，exception又包括了运行时异常和非运行时异常

   + error比如stackoverflow异常，在递归次数太多的时候；error是仅靠程序本身是无法处理和预防的，所以碰到error一般就需要中止程序。
   + runtime exception，常见的比如空指针异常，数组越界异常，这些可以从逻辑的角度来避免
   + 受查异常，比如IO异常这种必须经过捕捉来处理，否则不能编译通过。

2. Arraylist和LinkedList，ArrayList扩容，ArrayList删除符合条件的元素

   Arraylist是一种动态数组，容量可变，支持对元素的快速随机访问，但是插入和删除速度比较慢

   Arraylist扩容默认情况下是原容量的1.5倍，如果1.5倍大于期望容量，就返回1.5倍；如果小于期望容量，就返回期望容量，但是期望容量不能小于默认值10

   选择1.5是为了防止频繁的扩容影响性能

3. 深拷贝和浅拷贝，怎么实现深拷贝

   浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址；要拷贝的类实现了Clonable接口并重写Object类的clone()方法，然后在方法内部直接调用super.clone()方法。

   深拷贝会拷贝所有的属性，引用类型也会重新分配内存。需要类实现Cloneable接口并重写clone方法，创建引用类型的新对象，和原始对象相互独立。

   序列化拷贝属于深拷贝，使用这种方法将无法拷贝transient变量。再就是性能问题。

   

4. 迭代器

   对 Collection 进行迭代的类，称其为迭代器。通过iterator方法获取集合的迭代器对象。iterator接口定义了常见的迭代方法。hasnext判断集合中是否还有元素，如果有返回true；next方法，返回迭代的下一个元素，没有抛出异常nosuchelement；remove方法，移除迭代器返回的最后一个元素。

5. 四种修饰符

   public：本类，本包，包外子类，任何地方

   protected：本类，本包，包外子类

   default：本类，本包

   private：本类

**网络**

1. Get，post区别

2. 问点网络编程，为什么要TIME_WAIT？

3. 报文文在网络中停留的时间大概是多久？规范定义的*网络报文*的最大生存时间，linux指定30s

4. 无需登录账号实现购物车操作；用户没有登录, 添加商品, 此时的商品是被添加到了浏览器的Cookie中, 所以当再次访问时(不登录),商品仍然在Cookie中, 所以购物车中的商品还是存在的.

   1：Cookie： 优点： 保存用户浏览器（不用浪费我们公司的服务器） 缺点：Cookie禁用，不提供保存

   2：Session：（Redis ： 浪费大量服务器内存：实现、禁用Cookie）  速度很快

   3：数据库（Mysql、Redis、SOlr）  能持久化的就数据库  速度太慢

5. 还有一些防攻击的问题；csrf

**并发 数据库**

1. Object里面的方法，wait和sleep区别

2. 同步方法中锁的是什么：静态方法锁的是类class，一般方法锁的是对象class

3. 两个同步方法可不可以同时调用：两个都同步了不可以同时进入，但是可以在A执行的时候使用wait方法，然后进入B

4. Sql语句慢，怎么优化，索引失效，主键索引和唯一索引

   这种情况完全可以建一个联合索引，因为是最左前缀匹配，所以operate_time需要放到最后，而且还需要把其他相关的查询都拿来，需要做一个综合评估。

5. 表的数据过多查询慢怎么办：分表

6. mybatis是干啥的

7. sql注入是什么：web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作

   通过SQL注入能获取全部的数据库，表，及其字段，

   利用sql语言漏洞获得合法身份登陆系统 ，在输入框中添加 or 1=‘1 -- 注释了后半部分的sql

   使用参数化过滤语句，**使用正则表达式过滤传入的参数**

   采用预编译语句集，它内置了处理SQL注入的能力，只要使用它的setXXX方法传值即可。

   **${}**形式声明为SQL传递参数，mybatis将不会进行参数预处理，会直接动态拼接SQL语句，此时就会存在被注入的风险，所以在使用mybatis作为持久框架时应尽量避免采用**${}**的形式进行参数传递

   这种将安全责任抛给框架远比依靠程序员自身控制来的保险。因此如果项目使用JPA作为数据访问层，基本上可以很大程度的消除SQL注入的风险。

8. 多个线程连接一个数据库读取数据；线程池，在多线程的环境中，在不对connection做线程安全处理的情况下，使用单个connection会引起事务的混乱

9. 非常多的数据应该怎么插入表中？（批处理）

10. 主键索引和唯一索引有什么区别？查询起来又有什么区别，哪个快？（我答的是聚簇索引和非聚簇索引的区别，聚簇索引是表创建好以后随着主键一起创建的，索引和行数据是在一起的，所以查的快，非聚簇索引查询数据分两步走，所以查得慢）

11. 数据库用到最难复杂的一句sql

**设计**

1. 设计题，客户端每次随便输密码（每次输入不一样）也能合法登录服务器，如何实现这个功能
2. 设计类对象，用不同排序方法（首字母，汉语拼音，百家姓。。。）对一组名字排序，简述设计思路
3. 你觉得二维码登录过程牵扯到哪几步，简要说说
4. 如何增加二维码安全性？

**框架**

1. redis用消息队列去重：list列表可以实现队列，利用set集合可以实现去重，使用字符串的位操作，实现布隆过滤，或者hyperloglog，但是这个可能会有误差

2. redis缓存热点数据你怎么样清理呢：redis配置缓存策略**volatile-LRU(least recently used)**

   @EnableCaching RedisCacheManager

   @Cacheable

   这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的key就是方法的参数，缓存的value就是方法的返回值。示例代码如下：

3. 顺带着聊了聊缓存击穿，雪崩一类的东西

4. spring使用的时候用的是什么方式，说说常用注解吧

5. 如果我想在一个类启动的时候加载配置文件中的某个属性该怎么做

   @Value  @ConfigurationProperties（prefix=“remote”）

   @ConfigurationProperties需要和@Configuration配合使用，将会读取properties文件中所有以mail开头的属性，并和bean中的字段进行匹配

   通过@Value将外部配置文件的值动态注入到Bean中，自定义属性文件通过@PropertySource加载

   @Value("${book.name}")  @Value不能静态成员上使用；且使用了@value的类需要在容器中

   

6. 微服务了解？如何检测各个微服务的健康状态？一个业务报错了如何检测到是哪个服务哪个环节出现了问题？如何定位？

   微服务架构师将模块职责拆分明确，模块单独作为一个应用，必要的时候按照数据库存储需求给应用分配不同的数据库。每个微服务单独部署，每一个微服务都暴露了API供其他微服务调用。

   服务间的通信，可以使用**响应式，注册/订阅式**等异步手段，也可以使用消息队列。另外API网关(GateWay)不仅仅是负责微服务的通信中介，还负责**访问控制，监控，埋点，日志，负载均衡**等功能。

   为了实现高可用，微服务一般使用**Docker部署**，且每个微服务一般部署**多个实例**，每个Docker承载一个实例。用户请求时，使用**Nginx反向代理服务器**，去分发请求到不同的实例去。因此，乘客，司机等模块化的微服务的测试/发布流程，就没有关联性，让持续部署成为可能。

   **分布式:**微服务可以**解决复杂问题**，将庞大的单体应用分解成一套包含多个子服务的体系，实现了**强制模块化**。这样的好处是，子服务可以被快速开发，并且**单一职责**也便于维护。同时，分布式部署也能很好地应对**高并发需求**，减少部署开销。

   **松耦合:**微服务架构拆分了业务模型，影响到了应用和数据库的关系，其实应用之间的耦合，也都是因为数据依赖造成的。之前的单体应用中，所有模块可以共用一个mysql数据库。但到了微服务架构，都是分开部署的，就不得不将数据库也拆分了，并且利用**数据冗余**，**解除**掉单体数据库中的**数据耦合**。

   **分区数据库架构:**分布式事务**在微服务中是很**难实现的，在单体应用中，只存在一个单独的数据库，事务很容易实现。但是在微服务中，一般不会选择分布式事务，根据CAP定理，数据一致性，可用性，和分区容错性，只能三选二，要舍弃哪个就显得很痛苦。另外，分布式事务根本不支持高度可扩展的NoSQL数据库和消息代理。只能使用“最终一致性”的办法来进行折中。

   

7. 项目的用到的相关技术框架，为什么用

   有历史遗留问题，比如说数据库的选择。选择springboot是因为方便，开箱即用，约定大于配置，简化了配置工作，只需要通过maven添加相关依赖包，然后通过注解来代替xml来管理对象

   当我们的SpringBoot项目启动的时候，会先导入AutoConfigurationImportSelector，这个类会帮我们选择所有候选的配置，我们需要导入的配置都是SpringBoot帮我们写好的一个一个的配置类，那么这些配置类的位置，存在与META-INF/spring.factories文件中，通过这个文件，Spring可以找到这些配置类的位置，于是去加载其中的配置。

   

8. 职业规划，在工作中怎么成长

9. 接触过哪些新技术

10. 介绍一下Zookeeper的功能是什么？如何实现注册中心的功能？讲一下Zookeeper集群的选举机制？

    分布式协调服务，分布式数据一致性的服务封装，

11. CAP理论知道吗？Zk和eureka分别实现了哪两个？你为什么用nacos替代了Zk？

    一致性，可用性，分区容错性：只能选择CP或者AP架构

12. 分布式事务如何实现？分别有哪几种实现方式？

    rocketMQ

13. 项目是怎么部署的？怎么使用Jenkins？

    工作流在Jenkins中被称为pipeline，pipeline的运行行为由用户自己定义，定义的内容存放在一个Jenkinsfile文件中，并将该文件存放在git仓库的根目录，大致的流程如下：

    1. 用户将代码提交到git
    2. Jenkins从git拉取最新代码
    3. 读取根目录下的Jenkinsfile文件，并依次执行文件中定义的任务

    agent - 指定在哪台机器上执行任务，是production还是测试环境

    每次commit的时候自动执行pipline，需要使用git提供的hook，一旦提交就会触发其中的脚本。

    

14. 写过哪些Linux脚本，分别用来实现什么功能？nohup

15. 项目是怎么测试的？使用了哪些测试方法？具体介绍一下

16. 有使用什么团队管理工具吗？除了SVN以外？git

17. 平时有做日志分析吗？怎么做的？

18. 服务限流怎么做的？流量监控怎么做的？

19. 讲讲在你的架构中，如何使用网关？如何使用nginx？

20. 如何解决项目负载高得问题？

21. 让你设计一个秒杀系统，你怎么设计？

    

22. Spring的各种问题，事物的传播机制？AOP怎么实现？jdk，CGLIB有什么区别？打了两个事务注解的Service互相交织有什么问题？Bean是单例的吗？

    service已经不是简单的AccountService 的实现类了，而是实现类的代理对象，service内部方法打了注解相互调用没有开启事务。

23. 问redis怎么扣减库存 我说分布式所+lua+mq

**手撕**

1. 中途一个代码题，给一个整数数组，求连续三个整数的和的最大值
2. 写快速排序
3. 统计数组中每个元素出现的次数，并将结果输出
4. 简单socket通信
5. 递归二分查找
6. 算法：寻找最近公共父节点，leetcode 235
7. 给了我一张表，写一下这张表的建表语句，create语句手撕
8. 使用一条sql查出成绩大于90的（多加一列为良好）、成绩在60-90之间的（多加一列为及格）、成绩在60以下的（多加一列为不及格）
9. 

#### 字节跳动-商业变现

##### 基础

1. java面向对象的特性，多态的三个必要条件

2. **静态绑定和动态代理**

3. **堆和栈的区别**

4. **LRU的实现**

5. 封装有什么用；多态是怎么实现的？说了继承，接口和泛型

6. 接口和抽象类有什么区别？

7. 对集合的了解

8. Arraylist和LinkedList的区别 **Arraylist的初始大小**

9. Hashmap底层 扩容

10. ==跟equals的区别

11. 

    

##### 计算机网络

1. ~~登录状态如何保持？session、cookie、token怎么用，有什么区别？~~
2. ~~tcp/ip的四层模型、TCP 三次握手 四次挥手，挥手的时候需要等2msl~~
3. 描述一下向socket传值的流程？
   + 服务器根据地址类型（ipv4、ipv6）、socket类型、协议创建socket
   + 服务器为socket绑定对应的IP地址和端口号
   + 服务器监听端口号请求，接收用户发来的连接请求，此时服务器没有打开socket
   + 用户创建socket
   +  用户打开socket，并通过IP地址+端口号试图connect服务器的socket
   + 服务器接收到了用户发来的socket连接请求，被动打开socket，开始接收客户端请求，直到用户返回连接信息。这时候服务器的socket进入堵塞状态，所谓堵塞，即accept();方法一直接收到客户端返回连接信息后才返回，然后开始接收下一个用户端请求
   + 客户端连接成功，开始向服务器输入状态信息
   + 服务器accept();方法返回，连接成功
   + 客户端写入信息
   + 服务器读取信息
   + 客户端关闭
   + 服务端关闭
5. 输入URL到页面显示之后的整个过程
6. ~~*网络七层模型*~~
7. ~~http和https的区别；http是否无状态？如何有状态？http2.0特性？介绍一下http2.0。~~
8. ~~TCP和UDP的区别，视频面试用的是TCP还是UDP~~
9. 输入域名，长时间没有得到回应（原因排查）：考虑是不是DNS解析问题，网不好，ping一下试试看
10. http状态码



##### 并发

1. 锁
2. 进程通信方式、 线程通信方式
3. 如何保证线程安全，怎么看日志
4. 进程和线程的区别
5. 进程调度算法都有哪些
6. 实现单例模式（懒汉），考虑线程安全
7. one loop pre thread，timer fd定时器实现，redis 底层
8. 线程安全什么意思？如何线程安全？
9. 锁的种类？公平锁分公平锁？redis分布式锁是否公平锁？
10. 介绍一下线程池
11. 线程池的submit操作如何实现（也可能是一面的问题）
12. 线程池的饱和策略
13. 有界无界队列
14. 线程的创建方法



##### 其他

1. 编译型代码和解释型代码的区别
2. 用过消息队列吗? 是什么作用?
3. 在读什么书。
4. Jmeter压测的时候为什么会丢包
5. RocketMQ的实现
7. RPC有了解吗？远程过程调用：也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。
8. spring boot和spring的优劣势
9. RocketMQ有哪些组件



##### 数据库

1. B+树的结构：B+树每个节点是一个page，所有的key存储在叶子结点，内部节点都是索引。

2. B+树如何select range：先通过search找到range的起始叶节点，包括范围的起始值，沿着叶的链接读下一个叶节点，直到遇到范围终止值。

3. 叶子节点双向链表的作用：方便排序，支持前后遍历

4. SQL `LIMIT M, N` M / N 分别是什么：M是输出记录的初始位置，N是输出的个数；

   LIMIT 10 OFFSET 2：初始位置偏移2，输出10个。

5. MySQL的四个事务隔离级别, 怎么实现的

6. 两个人A->B跨系统转账的流程如何保证原子性?

7. left_join和right_join的区别：**Inner join**产生的结果集中，是A和B的交集。**Full outer join** 产生A和B的并集。但是需要注意的是，对于没有匹配的记录，则会以null做为值。**Left outer join** 产生表A的完全集（A是from后面的那个），而B表中匹配的则有值，没有匹配的则以null值取代。

8. 索引类型：聚集索引、非聚集索引、联合索引

9. 数据库的索引，唯一索引和主键索引：主键索引一定是唯一索引，但是唯一索引不一定是主键索引。只能有1个主键，但是可以有多个唯一性的索引，唯一索引允许为null

10. mybatis的缓存

   

##### Linux

1. linux 命令: 找出文件里的match的一行 (cat | grep 感觉不太好)

    grep 命令用于查找文件里符合条件的字符串

2.  linux如何创建文件：vi touch echo "adfs" > 3.txt

   mkdir 创建目录

3. 找出指定端口被哪个进程占用 list open file lsof -i:8080

   Netstat -tunlp | grep 8080 显示tcp，udp的端口和进程等的相关信息

4. loop epoll linux kernel（盲区） ipc 无锁编程 环形无锁队列 CAS无锁队列 地址重用（忘光了，unp有讲）

##### Redis

1. redis都有哪些了解：redis是一个非关系型数据库，在内存中存储，所以读写速递非常快。常用于缓存方便，也可以用来做分布式锁。支持事务，持久化。

2. 为什么要用缓存：高性能：因为是操作内存，所以直接从缓存中读取比从硬盘上读取要快很多；高并发：直接操作缓存能够承受的请求远大于直接访问数据库。

3. redis支持哪些数据类型：String，List，Set，Sorted Set，Map

4. redis是单线程还是多线程的，为什么这样设计？redis有没有并发问题：Redis的单线程模型指的是网络请求模块使用了一个线程，即一个线程利用IO多路复用处理所有网络请求，其他模块仍用了多个线程。因为redis的性能基于内存进行操作，cpu并不是它效率的限制因素，使用单线程还减少了切换线程带来的消耗。而在网络请求模块，使用epoll作为IO多路复用的实现，再加上事件处理模型。

5. redis的并发竞争key的问题：Redis并发问题：setnx

6. redis和其他数据库的区别

7. redis的数据结构。zset是什么？如何实现的？压缩列表和跳跃表，元素数量小于128个并且元素长度小于64字节使用压缩列表，其他情况使用跳跃表。

8. redis为什么快？内存+单线程。

9. redis的并发竞争key的问题：如何设计分布式锁？利用setnx，expire设置过期时间可以实现分布式锁，但是分两步造作不具备原子性，可以用lua脚本来保证原子性；新版的 set 命令增加了 EX 、 PX 、 NX|XX 参数选项，这样检查key是否存在，设置key过期时间可以在一个原子性操作中完成。

   释放锁的时候，需要先检查是不是自己持有锁，才能用del来删除，所以需要lua脚本来保证原子性。

   redis集群：redlock和redission来实现。

10. 利用redis的可重入锁如何设计？利用ThreadLocal实现，获取锁后将Redis中的value保存在ThreadLocal中，同一线程再次尝试获取锁的时候就先将 ThreadLocal 中的 值 与 Redis 的 value 比较，如果相同则表示这把锁所以该线程，即实现可重入锁。

11. 如果redis宕机了，或者链接不上，怎么办？配置主从复制，哨兵模式，一旦主机宕机，让下一个从机当作主机。

12. 如果redis缓存在高峰期到期失效，在这个时刻请求会向雪崩一样，如何处理？：

##### 手撕

1. quicksort：给一组数字，根据快排，第1次，第2次....的排序结果说一下

2. 金额找零 $M, N种不同面值的硬币, 找零怎么实现？

3. 如何优化子问题? （记忆化 -> dp）

4. 给定一个升序数组arr， 一个数字a，找出比a小的最大的那个数字。（二分）

5. 成绩表 SC(S#,C#,score) --S# 学生编号,C# 课程编号,score 分数，找出语文成绩及格，平均成绩不及格的学生编号。

   取出表中语文及格而数学不及格的同学的学号

   **用了or判断 踩到了坑 就是没去判断该同学是不是同时有两种成绩**

   ```sql
   select stu from table where c
   ```

   

6. 输出给定数字下一个比它大的数字，比如输入：1234， 输出 1243。

7. 删除驼峰式字符串

8. 目前有1分，3分，5分面值的硬币，要组成一个10分面值最少需要几个硬币

9. 一个文件，有两列数据，第一列是时间戳，第二列是IP地址，统计出有多少个不同的IP

10. 实现两个线程交叉打印你好

11. 算法题leetcode 3 滑窗即可

12. 算法题 leetcode 56 排序即可

13. 算法题 岛屿类似的题目 dfs/bfs都行

14. 1G文件，每一行一个词，每个词大小小于16B，1M内存限制，如何找到频率前K个词？此处1G文件远远大于1M内存，分治法，先hash映射把大文件分成很多个小文件，具体操作如下：读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为f0,f1,...,f4999)中，这样每个文件大概是200k左右（每个相同的词一定被映射到了同一文件中）；

    对于每个文件fi，都用hash_map做词和出现频率的统计，取出频率大的前100个词（怎么取？topK问题，建立一个100个节点的最小堆），把这100个词和出现频率再单独存入一个文件；

    我们又得到了5000个文件，**归并文件取出top100（Top K 问题，比较最大的前100个频数），小顶堆**

15. 验证对称二叉树。Leetcode 101。

16. 一个牌堆，先从顶部取一张牌放在桌子上，再从顶部取一个放在牌堆底部，循环这个过程，得到桌子上的一个牌序列，问根据这个牌序列求牌堆初始顺序。

    利用堆栈队列。如果手上牌大于1，将底放到顶，然后将桌上 的顶放到手上顶部，循环。

17. 回文串判断 leetcode125

18. 给一个链表，奇数位递减，偶数位递增，不使用额外空间，进行排序实现全部递增：

    先拆分奇偶，形成两个链表，然后奇数链表倒序，merge两个链表。

    ```java
    import java.util.*;
    public class Main{
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            String[] str = sc.nextLine().split(",");
            Node head = transfer(str);
            Node[] lists = splitList(head);
            Node list2 = reverseList(lists[1]);
            Node ans = merge(lists[0],list2);
            while(ans != null){
                System.out.print(ans.val+",");
                ans = ans.next;  
            }
            
        }
        private static Node merge(Node l1, Node l2){
            Node dummy = new Node(-1);
            Node cur = dummy;
            while(l1 != null && l2 != null){
                cur.next = l1;
                l1 = l1.next;
                cur = cur.next;
                cur.next = l2;
                l2 = l2.next;
                cur = cur.next;
            }
            if(l1 != null) cur.next = l1;
            return dummy.next;
        }
        private static Node reverseList(Node head){
            Node pre = null;
            Node next = null;
            while(head != null){
                next = head.next;
                head.next = pre;
                pre = head;
                head = next;
            }
            return pre;
        }
        private static Node[] splitList(Node head){
            Node dummy1 = new Node(-1);
            Node dummy2 = new Node(-1);
            Node l1 = dummy1;
            Node l2 = dummy2;
            int index = 0;
            while(head != null){
                if(index%2 == 0){
                    l1.next = head;
                    l1 = l1.next;
                } else {
                    l2.next = head;
                    l2 = l2.next;
                }
                head = head.next;
                index++;
            }
            l1.next = null;
            l2.next = null;
            return new Node[]{dummy1.next, dummy2.next};
            
        }
        private static Node transfer(String[] str){
            Node dummy = new Node(-1);
            Node cur = dummy;
            for(String s : str){
                Node tmp = new Node(Integer.valueOf(s));
                cur.next = tmp;
                cur = cur.next;
            }
            return dummy.next;
        }
    }
    class Node{
        public int val;
        public Node next;
        public Node(int value){
            this.val = value;
        }
        public Node(){}
    }
    ```

    

19. 给定一个表，**获取所有课程得分均大于80分的学生的平均得分**

    ```sql
    select distinct student.name from student 
    where student.name not in (
    	select distinct student.name from student where student.score < 80
    )
    
    select student.name from student group by student.name 
    having MIN(student.socre) >= 80
    ```

A B C线程，循环A B C


给定一个Consumer表，里面是客户相关的字段：id，name，regionId(区域),一个订单表Order，里面是订单相关字段：consumerId,amount,month，给出查询全年交易金额大于100万的客户来自哪些区域。

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必须获得更多的糖果那么这样下来，老师至少需要准备多少颗糖果呢？
示例 1:
输入: [1,0,2]输出: 5解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。​​

输出给定数字下一个比它大的数字，比如输入：1234， 输出 1243。
125431​

成绩表 SC(S#,C#,score) 
S# 学生编号,C# 课程编号,score 分数，
找出语文成绩及格，平均成绩不及格的学生编号，语文成绩，平均成绩。



#### 京东

##### Java

1. 说说JVM的理解 （JVM虚拟机重点章节基本都说了一遍）

   + 程序计数器：是线程私有的，可以看作字节码行号（运行本地方法的时候是undefined），字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转等功能都依赖程序计数器来完成。这里没有OOM，不需要GC。

   + 虚拟机栈：是线程私有的，每当有新线程创建的时候就会分配一个栈空间，与线程共存亡。存放每个方法被执行时创建的栈帧，保存的内容包括局部变量表，操作数栈，动态连接和方法返回地址。这块区域方法执行入栈，结束出栈，所以不需要GC。当线程请求的栈深度大于虚拟机允许的深度跑出StackOverFlowError，如果栈容量可以动态扩展，栈扩展无法申请足够内存抛出OutOfMemoryError（Hotspot不可动态扩容，不存在这个问题 ）
   + 本地方法栈：为虚拟机执行本地方法服务，本地方法是java调用非java代码的接口，可以和操作系统进行交互。也不需要GC。虚拟机规范对本地方法栈没有强制规定，Hotspot将虚拟机栈和本地方法栈合二为一。可能是C或者python等其他语言实现的
   + 本地内存：线程共享，通常叫堆外内存，包含元空间和直接内存。
     + 1.8之前是在堆中实现一个永久代，用作方法区，存储类型信息、常量、静态变量，受GC管理，但是由于MaxPermSize的限制，大量动态生成类可能会造成OOM，所以很难确定方法区/永久代的大小。
     + 1.8之后吧方法区的实现放在本地内存中，这样方法区不受JVM控制，也就不会GC。空间大小也足够，方便在元空间统一管理。
     + 1.4之后的NIO，可以使用Native函数库直接分配堆外内存，通过堆内对象作为这块内存的引用进行操作，避免了堆内堆外来回拷贝。
   + 

2. 新生代的对象什么时候会进入老年代（分3种情况，有一种我想不起来了）

   + 大对象直接进入老年代，因为大对象需要更多连续的空间来存放他们，所以可能会提前出发垃圾回收，直接放进老年代更有效率。大于虚拟机参数pretenureSizeThreshould的对象直接在老年代分配，可以避免新生代收集的大量复制。
   + 长期存活的对象会进入老年代：每个对象都有年龄，经过一次minor GC，年龄加一，超过参数MaxTenuringThreshold会晋升老年代
   + 如果在survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半，年龄大于或等于该年龄的对象可以晋升老年代

3. java gc 

   + 如何识别垃圾：引用计数法和可达性分析
     1. 引用计数法：无法解决循环引用问题
     2. 可达性分析：什么东西可以作为GCROOT？
        + 虚拟机栈中引用的对象；
        + 方法区中类静态属性引用的对象；
        + 方法区中常亮引用的对象；
        + 本地方法栈中JNI（native方法）引用的对象；

4. 如何使用代码来进行垃圾回收：System.gc 

   不建议使用，因为内存溢出是可以分析查找原因的，而使用system.gc进行主动垃圾回收是一个危险的动作，需要停止所有的响应，才能检查内存中是否有可回收的对象，严重影响业务。

5. 如果未及时gc回怎么样，用代码模拟一下out of mermory

   + 一直新建对象，堆oom
   + 一直递归，栈stackoverflow
   + 一直新建线程，栈oom

   ```java
   // 堆OOM 一直新建对象
   // 设置JVM的堆大小 -Xms 20m -Xmx20m
   public static class OOMObject{}
   public static void main(String[] args){
     List<Object> list = new ArrayList<>();
   	while(true){
   		list.add(new OOMObject());
   	}
   }
   // 虚拟机栈SOF -Xss256k
   // 递归深度
   public class StackOverFlowError{
     private int stackLength = 1;
     public void stackLead(){
       stackLength++;
       stackLead();
     }
     public static void main(String[] args){
       stackOverflowError oom = new StackOverFlowError();
       try{
         oom.stackLeak();
       }catch(Throwable e){
         System.out.println(oom.stackLength);
         throw e;
       }
     }
   }
   
   public class 
   ```

6. java常见数据类型

7. 集合有哪些？哪些是线程安全的?线程安全的list ，Map

   早期线程安全的有vector和hashtable，几乎所有的方法都加上了synchronized关键字；

   collections工具类提供了响应的包装方法将普通集合包装成线程安全的集合，在原集合的基础上添加了锁，每个方法都通过这个锁实现同步。

   JUC包中的集合：例如concurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet

   + concurrentHashMap：1.8之前，concurrentHashMap使用的是分段锁，也就是对Segment加锁，不同分段之间并发操作不受影响；get的效率高，不需要加锁，除非读到空值才会加锁重读；
   + 1.8之后，取消了分段锁，直接在table元素Node上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。而且1.8引入了红黑树，在转化过程中，同步锁锁住当前槽的首元素，防止其他线程对当前槽进行增删改操作；put，size，resize方法中涉及元素总量的更新和计算都使用CAS代替锁。put操作没有哈希冲突的时候使用CAS添加元素，否则使用synchronized加锁添加元素；
   + CopyOnWriteArrayList是list的线程安全集合，写操作的时候复制一个新的集合，在新集合内添加或删除元素，修改完成之后再将原集合的引用指向新集合。读操作可以并发执行。

8. lambda表达式和Strem流说了平时哪里用到了？

   结合 forEach 方法可以更方便地实现遍历。此外，它还可代替 Runnable 类，大大简化了代码的编写。

   使用 Stream 对象的 map 方法将原来的列表经由 Lambda 表达式映射为另一个列表

9. java异常平时用到了哪些？

   Throable包括了error和exception，exception又包括了运行时异常和非运行时异常

   + error比如stackoverflow异常，在递归次数太多的时候
   + runtime exception，常见的比如空指针异常，数组越界异常，这些可以从逻辑的角度来避免
   + 受查异常，比如IO异常这种必须经过捕捉来处理，否则不能编译通过。

10. 简单问下JDK1.7 和 JDK 1.8 ConcurrentHashMap 的底层数据结构相关的吧

11. 介绍HashMap /什么时候转为红黑树 /如何使HashMap线程安全 /介绍ConcurrentHashMap 

12. jvm中的引用有了解么？分别有哪些？具体介绍一下。

13. 类加载过程

14. java中基本的数据结构有哪些？基本数据类型以及所占内存？

15. 说下map吧，里面有哪些实现？源码看过么？说说其中的方法以及实现过程。

16. 说一下你看过哪些算法（回朔，dfs，动态规划）

17. 数据结构中的排序算法了解过么？具体说一说

18. jvm中内存模型有哪些？都可以存放哪些东西？

19. nio？

20. jvm中gc算法有哪些？讲一下分代回收算法

21. 怎么判断对象可回收？具体怎么实现？哪些对象可被gf root直接找到？

22. 说一下集合有哪些？具体说说map，说下1.8下的优化。

23. jdk1.8有哪些新特性？

24. final的作用

25. 反射相关

26. 动态代理相关

27. 怎么理解多态，原理是什么？不局限于Java，了解静态多态吗？父类对象赋给子类可以吗？

    



##### Java多线程 

1. 有哪些线程池？说说对这些线程池的理解吧？

   + Executors或者ThreadPoolExecutor的方法创建线程池
   + 核心参数：corePoolSize核心线程池大小，MaximumPoolSize线程池最大线程的大小，KeepAliveTime线程空闲后的存活时间，workQueue存放任务的阻塞队列，工作队列，handler当线程池和队列饱和之后的拒绝策略
   + FixedThreadPool：固定大小，核心线程数等于最大线程数，工作队列无界LinkedBlockingQueue，适合负载重的情况；
   + Cache 可缓存的线程池， 工作队列是没有容量的SynchronousQueue，如果主线程没有空闲，会新建线程，若有空闲，会回收。数量变化灵活，适合很多短期异步小任务、负载轻的情况
   + SingleThreadExecutor可以创建单线程化的线程池，只有一个工作线程，可以保重所有任务按照指定顺序执行FIFO
   + WorkStealingPool，1.8之后的，创建拥有足够线程的线程池支持给定的并行度，通过多个队列来减少竞争。
   + 有四种拒绝策略：discard直接抛弃任务，abort直接抛出异常，callerruns使用已存在的线程来处理任务，discardoldest放弃等待队列中最旧的一个

2. 你平时都是怎么用线程池？

   @EnableAsync @Async 用@confuguration配置类

3. Thread中 wait（）和sleep（）哪个是会有释放锁的操作？ wait会释放锁，

4. 看过AQS源码么，说说你的理解吧。AQS是一些同步组件，例如重入锁，读写锁的基础框架。使用一个volatile int state变量作为共享资源，内部有一个同步队列，来完成同步状态的管理，当前线程获取同步状态失败的时候，会将当前线程构造成一个结点，加入到同步队列中。同步器支持独占式也支持共享式（读写锁的读锁就是这种）

5. 让你设计，你会如何设计一个Reentrantlock。

6. 创建线程的几种方式以及区别 

   + 继承Thread，并重写run方法；如果这样就不能再继承别的类
   + 实现Runnable接口，重写run方法
   + 实现Callable接口，重写call方法；callable有返回值，future

7. 乐观锁悲观锁 / 悲观锁的应用场景 

   悲观锁：假设最坏的情况，每次去拿数据都有人在改变，所以每次都要上锁，独占锁reentranLock就是一种悲观锁，读写锁也是一种悲观锁，读的过程中不允许写

   乐观锁：假设最好的情况，不上锁，而在更新的时候判断一下有么有人改变了原数据，可以用CAS算法来实现。stampLock就是一种乐观锁，JUC包下的ATOMIC原子类变量就是用了乐观锁

   

8. 线程同步 

9. 线程池了解么，里面有哪些方法？

10. 线程池？为什么需要线程池？创建线程会消耗哪些资源？除了内存还有吗？了解会占用多少内存吗？

11. 怎么创建线程池？哪些参数？

12. 抠细节，线程池，核心线程数为10，最大为20，队列容量30。submit 25个任务，这25个任务是在线程池里是如何分布的？这个时候线程池已经创建了多少个线程？10个核心线程肯定创建了，剩下15个你觉得是直接创建线程来处理，还是等队列满了，再来处理？如果用的是无界队列，最大线程数的限制还有用吗？    

13. 线程安全解释一下，有什么方式来达到线程安全？synchronized修饰静态方法与非静态方法有什么区别

14. 假如A类中a()方法是非静态的，b()方法是静态的，两个方法都用synchronized修饰。线程t1,t2,t1调用a方法，t2调用b，t1已经获取了锁，t2还能进入b方法？

15. synchronized锁是公平的吗？公平锁与非公平锁的优缺点

16. 单例模式，懒汉，饿汉，静态内部类实现

17. 使用线程池，如果有一批任务想等它完全执行完之后，在执行下一批任务，怎么做？不知道



##### Mysql  

1. 为什么会有索引，说说主键索引和非主键索引的几个特点吧。

   索引可以大大提高MySQL的检索速度。在有大量数据，查询比较频繁，而新建，修改等操作比较少时，可以创建索引，这样查询的速度会比以前快很多。

   索引其实是存储引擎用于快速查找的一种数据结构。

   非主键索引的叶子节点存放的是**主键的值**，而主键索引的叶子节点存放的是**整行数据**。非主键索引也被称为**二级索引**，而主键索引也被称为**聚簇索引**。非主键索引的检索需要回表。

2. 有哪些隔离级别；然后最后一种隔离级别会出现什么问题，Mysql是怎么解决这个问题的。

   mysql通过next-key lock 对行（record lock）加锁 gap lock 间隙锁，每次锁住要使用的数据，还锁住这些数据附近的区域

3. 唯一索引和普通索引的区别，哪个查询更快一些，为什么？

   普通索引一般就是，为那些最经常出现在查询条件（WHERE column=）或者排序条件（ORDERBY column）中的数据列创建索引。

   唯一索引是为了避免重复数据的出现。

   在一个列上同时建唯一索引和普通索引的话，mysql会自动选择唯一索引。对于唯一索引来说，由于需要判断唯一性，所以要从磁盘中读取所在的数据页到内存中，判断到没有冲突，插入值，结束

4. 说一下熟悉的sql语句

   join on

5. 加索引需要注意什么 

   选择合适的列加索引

6. 最左前缀优先 

7. 说一下你对mybatis的理解

8. MVCC

   在MySQL中，会在表中每一条数据后面添加两个字段：

   创建版本号：创建一行数据时，将当前系统版本号作为创建版本号赋值

   删除版本号：删除一行数据时，将当前系统版本号作为删除版本号赋值

   select时读取数据的规则为：创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。

   创建版本号<=当前事务版本号：保证取出的数据不会有后启动的事务中创建的数据。这也是为什么在开始的示例中我们不会查出后来添加的数据的原因

   删除版本号为空或>当前事务版本号：保证了至少在该事务开启之前数据没有被删除，是应该被查出来的数据。

9. 聊项目、缓存一致性

10. mysql binlog日志干嘛的？备份 binlog日志的集中写入方式？不知道

11. 脏读与幻读解释一下

12. InnoDB和myisamDB区别

    



##### 网络

1. tcp中三次握手？四次挥手？为什么要四次？具体说说。

   SYN	 SYNACK	 ACK 	SYN_SENT 	SYN_RECV	Established

   FIN FINWAIT ACK CLOSE_WAIT  FIN LAST_ACK   ACK  TIME_WAIT CLOSED

2. http和https了解么？到什么程度？

   https是在http的基础上，加上了安全套接字层或者传输层安全，一种更安全的应用层协议。

   https和http的不同之处在于，https是加密的，需要CA证书，并且默认端口号是443。

   https的加密过程：

   + 客户端先向服务端发送一套他自己支持的加密规则；
   + 服务端选择一套加密规则，并将自己的身份信息，包括公钥，网站地址和证书颁布机构；
   + 客户端检验收到的证书的合法性；
   + 检验通过，客户端随机生成一个密钥，使用前面提到的公钥进行非对称加密，使用hash算法对握手信息进行摘要计算，并使用随机生成的密钥进行对称加密。把加密过后的随机密钥和摘要信息一起发送给服务端；
   + 服务端使用私钥解密，得到对称加密的密钥，然后用这个密钥解出hash摘要，并检验握手信息是否一直。一致，将握手信息对称加密发送给客户端。
   + 客户端接收信息，解密检查握手信息。之后的信息都用这个对称加密的密钥进行加密。

3. http接口性能调优，从最初的数据库出发：explain查看sql执行情况，每个字句的访问类型（是全表扫描还是索引范围扫描），实际上使用的key。可以用nosql来引入缓存，

4. 100万数据快速查询：

5. 如何设计一个网关，用来过滤黑名单：nginx的配置文件里用deny来过滤ip或者地址段，allow某个ip

   Nginx是采用服务器负载均衡进行转发
   Zuul依赖Ribbon和eureka实现本地负载均衡转发
   相对来说Nginx功能比Zuul功能更加强大，能够整合其他语言比如lua脚本实现强大的功能，同时Nginx可以更好的抗高并发，Zuul网关适用于请求过滤和拦截等。

6. 网关可以加缓存吗？为什么

   

7. 浏览器输入一个网址之后的请求过程？

8. Cookie与Session的区别，如何选择？用户浏览记录选什么？

9. TCP是如何保证可靠的？滑动窗口是干什么的？快重传是什么？

10. ping IP地址，在这个过程中，Mac地址起到的是什么作用？

11. SQL注入？XSS，CSRF攻击

​	

##### 你常用的设计模式

1. 常用 ：责任链 + 工厂模式

2. 假如你的责任链不断膨胀该怎么处理，有什么好解决方案么？比如现在你的handle 从10个膨胀到100个？

​	（思考了一会给了简单的答案（拆分为接口方法），但是面试官不满意，然后指导了一下（需要做业务拆分，提到用ForkJoin分治的思想）

​	

##### 组件框架 

1. spring注解有哪些：Component，Controller，Service，Repository，Configuration，Bean，Autowried，Qualifier限制注入的bean名称

2. 注解的工作原理，怎么使用的

   + 在框架启动的时候，有一个classPathBeanDefinitionScanner会扫描包；
   + 这个Scanner在初始化的时候设置了注解过滤器，用来判断class文件中的类是否要放入容器；
   + 扫描包下的class文件，把有注解的生成BeanDefinition，并注册到容器中去
   + 在使用的时候自动注入

3. redis常用命令 ？redis常用数据类型？项目中如何操作redis的?

   

4. 那么多缓存为什么选择redis?说了自己只了解过redis和memache，然后说了redis比memache强的地方

   

5. 为什么redis单线程也这么快？

   

6.  问了两个redis参数设置的是多少？不知道，也没记住那两个参数的名字，没设置过

   

7. servlet中请求转发与请求重定向的区别

   + 请求转发：request.forward（）转发是在服务端起效果的，浏览器感觉不到；地址栏不会改变
   + 重定向：重定向会有两次请求和响应，response.sendRedirect （）；地址栏会改变为重定向之后的路径。因为重定向会产生两个request对象，所以重定向的时候使用request作用域会没有效果。可以跳转外网



##### **设计题**

**来我们设计一个秒杀场景吧。单节点TPS可以达到30w/s哪种？**

秒杀的核心问题就是**极高并发处理**，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的**核心思路是流控和性能优化**。

控流：客户端进行访问限制，屏蔽用户的高频请求，比如用js来限制点击次数，防止用户过度刷接口；服务端限流一般通过异步处理、消息队列、并发限制等方式实现，比如写请求，做请求队列；读请求通过缓存（比如redis）来限流。



如何实现一个生产者消费者模型，使用什么数据结构？ 



##### 算法

1. 介绍一下快排（口述）

   快排算法的重点是选定一个基数进行划分排序，我一般选择数组的手元素作为基数。partition方法中，使用双指针i，j进行双向遍历，i从左往右找到第一个大于基数的数字，j从右往左找第一位小于基数的数字；找到之后将两个数字交换，循环上面说的直到i>=j结束循环 ；

   一次partition结束之后返回基数的下标，递归排序基数左边的数组，递归排序基数右边的数组。

2. 如何判断链表有环（口述） 

   快慢指针：用两个指针，都从头开始，一个每次前进一步，另一个每次前进两步，如果这两个指针值为null，表示没有环；如果出现两个指针相遇了，就表示有环路存在。

3. 无向图有换：dfs，判断是否已经在前面的路径中出现过了。并查集：初始化每个值的parent都是自己，遍历edges，如果两个结点的parent相等，即已经有路径连同他们两个，表示环路已经出现。

4. **创建10个线程，执行打印操作，使得打印结果循环按顺序出现1-2-3-4-5**

5. 字符串匹配

6. int的数组，元素有重复的，如何找出出现次数top 5的元素？你选用哪种数据结构?

   TreeMap：遍历数组，map中保存的是数组中的值，和出现的次数，TreeMap提供Comparator方法，按照次数从小到大进行排序





