## 设计模式

什么是模式设计Design Pattern？代码设计经验的总结

### 23种设计模式

分为3个类型：

+ 创建型模式：**单例**、抽象工厂、**工厂**、建造者、原型
+ 结构型模式：**适配器**、桥接、**装饰**、组合、**外观**、享元、代理
+ 行为型模式：**模版方法**、**命令**、迭代器、**观察者**、中介者、备忘录、解释器、**状态**、**策略**、职责链、访问者

#### 创建型模式

##### 单例模式

> 数据库连接、日志、配置类、IOC依赖注入的时候

开发中用的最多的一种设计模式。





#### 结构型模式

##### 装饰模式

如果需要扩展功能，而不希望改变原来的这个类，一般有两种模式：

+ 继承
+ 关联：委派的一种，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为来扩展自己的行为，我们称这个嵌入的对象为装饰器（decorator）

装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。

![image-20200701210230134](/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200701210230134.png)

我们把咖啡本身当做是主要的本体，而把奶泡等调料当做是咖啡的装饰，我们通过给本体添加不同的装饰来获得不同的结果。

我们以DarkRoast为例，这种咖啡是继承自Beverage的，它的cost（）是用来返回咖啡的价格。

如果客户想要摩卡咖啡，就建立一个Mocha对象，并用他将DarkRoast对象包起来（装饰）。Mocha就是一个**装饰者，他的类型和他所装饰的类型是一样的，都是Beverage**。Mocha也有一个cost方法，它的cost（）方法会首先调用所装饰的对象DarkRoast类的cost（）方法获得咖啡的价格，然后再加上自己本身的价格形成最后总的价格。

**优点**

+ 装饰模式比继承更灵活；
+ 动态的方式对功能进行扩展；
+ 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。

**缺点**

+ 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。



##### 适配器模式

假设一个软件系统，你希望它能和一个新的厂商类库搭配使用，但是这个新厂商所设计出来的接口，不同于旧厂商的接口。你不想改变现有的代码，解决这个问题（而且你也不能改变厂商的代码）。可以写一个类，将新厂商的接口转化成你所希望的接口。

经过上边的三个例子，我们可以总结出适配器模式的使用过程：
1、客户通过目标接口调用适配器的方法对适配器发出请求。
2、适配器使用被适配者接口把请求转化成被适配者的一个或多个调用接口。
3、客户接收到调用的结果，但并未察觉这一切是适配在起转化作用。

所以适配器模式的正式定义就是：

适配器模式将一个类的接口，转化成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

**对象适配器**

适配器其实是分为对象适配器和类适配器两种，两种的工作原理不太一样。

对象适配器是使用**组合**的方法，在Adapter中会保留一个原对象（Adaptee）的引用，适配器的实现就是讲Target中的方法**委派**给Adaptee对象来做，用Adaptee中的方法实现Target中的方法。

我们的适配器继承自鸭子类并且保留了火鸡的引用，重写鸭子的飞和叫的方法，但是是委托给火鸡的方法来实现的。在客户端中，我们给适配器传递一个火鸡的对象，就可以把它当做鸭子来使用了。

**类适配器**

与对象适配器不同的是，类适配器是通过类的继承来实现的。Adpater直接继承了Target和Adaptee中的所有方法，并进行改写，从而实现了Target中的方法。这种方式的缺点就是必须实现Target和Adaptee中的方法，由于Java不支持多继承，所以通常将Target设计成接口，Adapter继承自Adaptee然后实现Target接口。

**缺省适配器**







##### 外观模式



#### 行为型模式

##### 观察者模式

定义了对象之间一对多的关系，一旦一个对象发生改变，他的所有依赖者



##### 模版方法模式



### JDK中常用的几种设计模式

单例模式：Runtime、Calendar和其他的一些类中；

工厂模式：被用于各种不可变的类，如Boolean.valueOf；

观察者模式：Swing和很多事件监听；

装饰器模式：多个IO类中。

### 什么是设计模式？你的代码中哪里用到了？

设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸。

单例模式：数据库连接池、线程池、日志、配置类/配置文件、IOC依赖注入

工厂模式：KieSession、代理newProxyInstance

命令模式：drools的firerule



### Java中什么叫单例设计模式？

单例设计模式重点在于整个系统上共享一些创建时比较消耗资源的对象。整个应用中之维护一个特定类实例，它被所有组件共同使用。Java.lang.Runtime是典型的单例模式

### 什么叫观察者设计模式？

观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是天气系统，天气变化展示在公众的视图中。

### 使用工厂模式的好处是？在哪里使用？

工厂模式增加了创建对象的封装层次，使用工厂来创建对象，只需要修改原始的实现类，而不需要在调用层做任何修改。

### 装饰模式举例？作用于对象层次还是类层次？

装饰模式增强了单个对象的能力。Buffered系列类如BufferedReader，通过 构造方法增强了Reader对象。已实现提升性能的Buffer层次的读取和写入。public BufferedReader(Reader in) 

### 为什么不能从静态方法中访问非静态变量？

非静态变量是和对象实例关联的，而静态的却没有任何实例关联。

### 设计一个ATM机？

加锁、事务、错误条件、边界条件

状态模式，一种状态下含有各种操作：

要想实现“状态包含个个动作”的最好的方式就是为每个状态声明一个类，然后在类中实现该状态下的不同的操作。所以我们创建了两个接口，一个是状态接口StateType，另一个则是ATM机接口ATMType。在StateType中声明了状态要包含的动作，因为这些动作也是ATM机的动作，所以我们的ATMType接口也遵循StateType接口。这也等同于ATMType中同样声明了这些动作，这些动作也是ATM机必须实现的。

### 什么情况下会更倾向使用抽象类而不是接口？

在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。

### 什么是MVC设计模式？请例举一个MVC设计模式案例。

### Java中FrontController设计模式是什么？请例举一个FrontController设计模式案例。

### Responsibility设计模式是什么？

### Adapter设计模式是什么？请例举一个在Java中的Adapter设计模式案例。