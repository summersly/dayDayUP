## 操作系统&Linux

### 1. 背景知识概念

#### 1.1 *什么是操作系统

+ 是管理计算机硬件与软件资源的程序，包括对资源、处理器、存储器、文件、设备的管理。本质上是运行在计算机上的软件程序，能够为用户提供一个与系统交互的操作界面，命令行或者图形界面的形式。
+ 基本功能：
  + 进程管理：进程控制、同步、通信、死锁处理、调度
  + 内存管理：内存分配、地址映射、保护与共享、虚拟内存
  + 文件管理：文件存储空间的管理、目录管理、文件读写管理和保护
  + 设备管理：完成用户的IO请求，缓冲管理、设备分配、设备处理、虚拟设备
+ 四大特征 ：
  + 并发：并发是指两个或多个事件在同一时间间隔内发生，宏观上是同时进行，但是微观上是交替执行的（区别于并行）。
  + 共享：系统中的资源可供多个并发进程共同使用，可以是互斥共享（互斥共享的资源--临界资源，例如打印机，同一时刻只允许一个进程访问，需要同步机制的控制），也可以是同时访问。
  + 虚拟：一个物理实体转换为多个逻辑实体。两种虚拟技术：时分复用、空分复用。多个进程能在一个处理机上并发执行就是使用了时分复用。虚拟内存使用了空分复用技术，将物理内存抽象为地址空间，每个进程都有自己的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部存在物理内存中，当使用一个没有物理内存的页时，执行页面置换算法，将该页置换到内存中。
  + 异步：进程的执行情况不可知。

#### 1.2 *什么是系统调用

如果一个进程正处于用户态，当他需要使用内核态的功能的时候，比如说要进行进程控制或者IO操作，这时候进行系统调用而陷入内核，由操作系统代为完成。

常见的有：fork、wait、exit、open、read、write

#### 1.3  *现代的操作系统结构

+ 大内核：操作系统的功能作为一个整体放在内核中，各模块共享信息，性能很高。

+ 微内核：由于操作系统逐渐复杂，因此将一部分功能移除内核，从而降低内核的复杂性。移除的部分根据分层的原则划分为若干服务，相互独立，运行在用户态。微内核只是操作系统最基本的部分，是操作系统的小核心，它将各种操作系统共同需要的核心功能提炼出来，形成微内核的基本功能。

### 2. 操作系统的硬件环境

#### 2.1 中央处理机

一般的处理机由运算器、控制器、一系列的寄存器以及高速缓存构成。

+ 运算器实现任何指令中的算术和逻辑运算，是计算机计算的核心；
+ 控制器负责程序运行的流程，包括取指令、维护处理机的状态、处理机与内存的交互；
+ 寄存器是指令在处理机内部做处理的过程中，暂存数据、地址以及指令信息的存储设备；**访问速度最快**
+ 高速缓存处于处理机和物理内存之间，一般由控制器中的内存处理单元MMU管理，访问速度高于内存，低于寄存器。它利用程序局部性原理是的告诉指令处理和低速内存访问得以匹配，提高了处理机的效率。

##### 寄存器

最常见的控制和状态寄存器包括

+ 程序计数器（Program Counter，PC），它记录了将要取出的指令的地址；
+ 指令寄存器（Instruction Register，IR），它包含了最近取出的指令；
+ 程序状态字（Program Status Word，PSW），它记录了处理机的运行模式信息等，有的处理机中还包含条件码。专门的寄存器来指示处理机状态。

##### 处理机的状态

多数系统将处理机工作状态划分为**管态和目态**。

+ 前者一般指操作系统管理程序运行时的状态，**具有较高的特权级别，又称特权态（特态）、系统态**；当处理机处于管态时，全部指令（包括特权指令）可以执行，可使用所有资源，并具有改变处理机状态的能力。
+ 后者一般指用户程序运行时的状态，具有**较低的特权级别，又称普通态（普态）、用户态**。当处理机处于目态时，就只有非特权指令能执行
+ 另外，还有些系统将处理机工作状态划分为多个系统状态，例如**核心状态、管理状态和用户程序状态**（又称目标状态）3种



#### 2.2 存储系统

存储器的类型：一种是读写型存储器（Random Access Memory，RAM），另一种是只读型存储器（Read-Only Memory，ROM 向其中写入数据只能用特殊方法进行）。在微型计算机中，通常把一些**常驻内存的模块**以微程序形式固化在ROM中。

+ 寄存器 > 高速缓存 > 内存储器 > 硬盘存储器 > 磁带机/光盘存储器

##### 存储分块

存储的最小单位：二进制位

为了简化存储器的分配和管理，在不少计算机系统中吧存储器分成块。在为用户分配内存空间的时候，以块为最小单位（物理页），块的大小随计算机而异。

##### 存储保护

必须对内存中的信息加以严格的保护，使操作系统及其他程序不被破坏。

+ 界地址寄存器：在处理机中设置**一对界限寄存器**来存放该**用户程序在内存中的下限和上限地址**，分别称为下限寄存器和上限寄存器（也可以是基址+限长）。每当处理机要访问内存时，硬件自动将被访问的内存地址与界限寄存器的内容进行比较，以判断是否越界。如果未越界，则按此地址访问内存，否则将产生程序越界中断（或称存储保护中断）
+ 存储键：每个存储块都有一个存储保护键，在一个程序运行在处理机上时，操作系统将它的存储键号码放进程序状态字中。每次访问内存都核对存储键是否对的上号。



#### 2.3 缓冲技术与中断技术

##### 缓冲

+ 处理机和内存之间：高速缓存
+ 处理机和其他外围设备之间
+ 设备和设备之间

主要是为了解决部件之间速度不匹配的问题。

##### * 中断

中断，**是指处理机对系统中或系统外发生的异步事件的响应。**

+ **能充分发挥处理机的使用效率，避免轮询或等待。**因为I/O设备可以用中断的方式与处理机通信，报告其完成处理机所要求的数据传输的情况和问题，这样可以免除处理机不断地查询和等待，从而大大提高处理机的效率。
+ **提高系统的实时能力。**能够立即运行某设备的处理程序

分为：

+ 外中断：由CPU执行指令以外的事件引起，如IO中断、时钟中断
+ 异常：CPU执行指令内部的事件引起，非法操作码、地址越界、算术溢出
+ 陷入：系统调用



### 3. *进程/进程管理

前驱图：有向无循环图，图中的每个节点用于表示一条语句、一个程序段或者进程。前驱图中不能存在环。

#### 3.1 进程/线程/程序

**进程**是程序在一个数据集合上的一次执行过程，是系统进行资源分配和调度的独立单位。进程的控制表叫做PCB。

**线程**是进程的一个实体，一个进程可以有多个线程，多个线程也可以并发执行。线程可以看作是一种轻量级的进程。线程的控制表TCB，但是其中保存的状态信息比PCB少很多。

**程序**是一个静态的概念，作为一个静态文件存储在计算机系统的硬盘等存储空间中。而进程则是处于动态的概念，是程序的一次执行，一个进程可以执行多个程序，由操作系统维护的系统资源管理实体。

**区别**：

+ 进程是资源分配的基本单位，但是线程只能访问隶属进程的资源；
+ 线程是独立调度的基本单位，同一个进程中的线程调度不会引起进程切换；
+ 进程创建和销毁的系统开销比较大；
+ 线程通信更方便，读写同一进程中的数据就可以，进程通信需要通过IPC（进程间通信）。

##### 进程特征

+ 动态
+ 并发
+ 独立
+ 异步
+ 结构特征：从结构上看，进程实体是由**程序段、数据段及进程控制块PCB**3部分组成，有人把这3部分统称为“进程映像”。

##### 线程实现机制

+ 用户级线程：仅存在于用户级进程。切换速度更快，更简单；系统调用的时候整个进程会被阻塞；执行时间的调度是以进程为单位的，可能并不公平。
+ 内核支持线程：依赖于内核的，无论是在用户进程中的线程，还是系统进程中的线程，创建销毁切换都是内核完成的。速度不如用户级线程，类似进程调度；系统调用只阻塞当前线程，可以调度该进程中的其他线程执行；执行时间的调度是以线程为单位的，线程多可以获得更多的执行时间。

#### 3.2 进程状态-4

+ 就绪状态：等待被调度ing，就差处理机的获得了，就绪队列
+ 执行状态：获得处理机了，正在执行
+ 阻塞状态：等待资源ing，因为IO或者申请缓存空间之类的原因暂停执行的状态，阻塞队列
+ 挂起状态：处于执行状态就暂停，处于就绪状态就暂不接受调度；suspend() 活动就绪--静止就绪；活动阻塞--静止就绪; active() 激活
+ **只有就绪--执行是双向的**

#### 3.3 进程控制

进程控制一般由操作系统的内核来实现，用户程序通常运行在用户态，不能去执行操作系统指令和访问操作系统区域。

##### 进程控制块PCB

PCB记录了操作系统所需的、用于描述进程情况及控制进程运行所需的全部信息。

**操作系统是根据PCB来对并发执行的进程进行控制和管理的。**

**进程控制块中4方面信息：**

+ 进程标识符信息：一个进程有两种标识符（外部标识符、内部标识符），外部标识符是给用户进程在访问该进程时使用，内部标识符是为了**方便系统使用**的一个唯一整数，进程序号。
+ 处理机状态信息：由处理机各种寄存器中的内容所组成，当处理机被中断时，所有这些信息都必须保存在被中断进程的PCB中，以便在该进程重新执行时能从断点顺序执行。包括通用寄存器、指令计数器、程序状态字PSW、用户栈指针；
+ 进程调度/对换信息：进程状态、进程优先级、其他、调度算法相关其他信息、由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。
+ 进程控制信息：程序和数据的地址、进程同步和通信机制、资源清单、链接指针（本进程所在队列中的在一个进程的PCB地址）

**进程控制块的2种组织方式**

+ 链接：相同状态的进程控制块PCB链接成一个队列，这样可以形成就绪队列、若干个阻塞队列和空队列；
+ 索引：根据进程状态构建索引表，就绪索引表、阻塞索引表，各个索引表的首地址记录于内存中的一些专用单元。



**操作系统的内核？**

一些与硬件紧密相关的模块，中断处理、设备驱动、进程调度等被安排在紧靠硬件的软件层次中，并常驻内存。这部分就称为内核。**往往是通过执行各种原语操作来实现的**

+ 中断处理：内核最基本的功能，操作系统的活动依赖于中断；
+ 进程管理：进程的建立和撤销，状态转变，调度，并发控制；
+ 资源管理中的基本操作。



#### 3.4 进程调度

进程调度就是系统按照某种算法把处理机动态地分配给某一就绪进程。进程调度工作是通过进程调度程序来完成的。

**进程调度程序：通过进程调度算法来选择占有处理机的进程，进行进程上下文的切换。**

**3个等级的调度：**

+ 高级调度：作业调度/接纳调度，决定将哪些在外存上处于后备状态的作业调入主机内存，为作业创建进程，分配资源，并挂到就绪队列上。执行频率低。
+ 中级调度：在内存和外存对换区之间进行进程对换，吧内存中处于等待状态的进程调到外存，将外存中具备运行条件的进程重新调入内存，以解决内存紧张。
+ 低级调度：进程调度，决定就绪队列中哪个进程将获得处理机，并将处理机分配给他。执行频率高。

**2种调度方式：**

+ 非剥夺方式：直到进程完成或发生某事件（IO）而阻塞的时候，才把处理机分配给另一线程；简单开销小、但是对端进程而言是不公平的，延误时机。
+ 剥夺方式：系统会剥夺一个正在进行的进程的处理机，根据某种原则（优先级、短进程优先、时间片原则）分配给其他进程。

**7种进程调度算法：**

+ 先进先出：FIFO，就绪队列先到先得，易于实现，表面公平，但是服务质量不好，对短进程不公平，所以常作为辅助调度算法。
+ 最短处理机运行期优先调度算法：从就绪队列中选出“下一个处理机执行期”最短的进程，短作业优先，如果一直有短进程进来，这样就会导致长作业进程饿死。下一个进程的执行期是估计的。
+ 最高响应比优先调度算法：非剥夺算法，<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200718212320845.png" alt="image-20200718212320845" style="zoom:50%;" />短进程优先，但是由于长进程等待时间变长，也能轮得到。
+ 优先级调度算法：将处理机分配给就绪队列中优先级最高的进程。通常确定优先级的方法有两种，即静态优先级法和动态优先级法。
+ 时间片轮转调度算法：**先进先出原则**轮流地调度就绪队列中的进程，但是有一个定时时钟，定时发出中断，去选择新的进程。
+ 前后台调度算法：前后台调度算法用在批处理和分时相结合的系统中。将分时用户程序放在前台，把批处理程序放在后台。系统对前台程序按照时间片轮转法进行调度，仅当前台无程序时，才把处理机分配给后台程序的进程。后台进程通常按先来先服务方式运行。这样既能使分时用户进程得到及时响应，又提高了系统资源的利用率。
+ 多级反馈队列轮转算法：有多个不同优先级的队列，低优先级只有等高优先级的队列为空，才能轮上。无论什么时候，只要 高优先级的队列中有进程进入，立即转到进程调度，及时调度最高优先级的队列进程。一个进程在第一梯队没有执行完，会被移入下一个队列

| 批处理系统 | 先进先出            | 非抢占               |
| ---------- | ------------------- | -------------------- |
|            | 短作业优先          | 非抢占               |
|            | 最短剩余时间优先    | 抢占                 |
| 交互式系统 | 时间片轮转          |                      |
|            | 优先级（静态/动态） |                      |
|            | 多级反馈队列        | 时间片和优先级的结合 |
| 实时系统   |                     |                      |



#### 3.5 Linux进程

**Linux中的PCB进程控制块**

task_struct

**Linux进程的控制**

+ 建立：fork创建新进程，原进程是父进程，新进程是自进程。除了pid不同以外，代码段和数据的内容都一样。
+ 执行：exec启动进程；
+ 等待子进程结束：wait
+ 结束子进程：exit

**Linux进程调度**

+ 实时进程：优先级更高，采用时间片轮转（RR）和先进先出（FIFO）2种；
+ 普通进程：优先级调度策略

**Linux软中断机制（Bottom Half）**

编写驱动的时候，一个中断产生之后，内核在中断处理函数中可能需要完成很多工作。**但是中断处理函数的处理是关闭了中断的。也就是说在响应中断时，系统不能再次响应外部的其它中断。这样的后果会造成有可能丢失外部中断。**于是，linux内核设计出了一种架构，中断函数需要处理的任务分为两部分，**一部分在中断处理函数中执行，这时系统关闭中断。另外一部分在软件中断中执行，这个时候开启中断，系统可以响应外部中断。**



### 4. 进程同步

进程之间的关系：

+ 资源共享
+ 相互合作

#### 4.1 临界区

**进程同步的主要任务就是保证进程能够互斥的访问临界资源。例如生产者-消费者。**

在每个进程中访问临界资源的那段代码称为临界区（Critical Section）。

每个进程在进入临界区之前应先对欲访问的临界资源进行检查，看它是否正在被访问。

**同步机制应遵循的准则：**

+ 空闲可以进
+ 忙则等待
+ 有限等待，让权等待

#### 4.2 信号量机制

操作系统进行管理的，P（value--）V（value++）操作是原子操作

+ **记录型信号量机制**：一个用于代表资源数目的整型变量value外，还有一个进程链表L，用于链接所有等待该信号量代表资源的进程。

  s.value的初值表示系统中某类资源的数目，因而又称资源信号量。

  每次的wait操作意味着进程请求一个单位的资源，因此描述为s.value--；当s.value＜0时，表示资源已分配完毕，因而进程调用block原语，进行自我阻塞，放弃处理机并插入到信号量链表s.L中。该机制遵循了让权等待准则。**此时s.value--的绝对值表示在该信号量链表中已阻塞进程的数目**。

  每次signal操作，表示执行进程释放一个单位资源，故s.value++操作表示资源数目加1。若加1后仍是s.value<=0，则表示在该信号量链表中仍有等待该资源的进程被阻塞，故还应调用wakeup原语，唤醒进程访问临界资源。

+ **信号量集机制**：

  + AND型信号量集机制：多个共享资源的时候，可能会发生死锁。AND同步机制的基本思想是：对若干个临界资源的分配采取原子操作方式，要么全部分配到进程，要么一个也不分配。
  + 一般“信号量集”机制：一个信号量可以获取多个。

#### 4.3 经典同步问题

+ 生产者-消费者
+ 读者-写者
+ 哲学家进餐
+ 嗜睡的理发师

#### 4.4 管程机制

管程也是一种用于多线程互斥访问共享资源的程序结构，采用面向对象的方法，简化了线程间的同步控制。任意时刻只有一个西三成执行管程代码



### 5. 进程通信

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。**3大类：共享存储、消息传递、管道通信**

+ 管道：pipe函数创建，只能单向交替传输，只能在父子进程中使用；
+ FIFO：有名管道，不一定是父子进程了；客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。
+ 消息队列：消息队列可以独立于读写进程存在，避免了FIFO同步管道打开和关闭过程产生的问题；避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法；读进程可以有选择的接受消息，而不是默认接受。
+ 信号量：一个计数器，表示资源数量；
+ 共享存储：需要使用信号量来同步对共享存储区域的访问，最快的IPC；
+ 套接字：不同机器之间的进程通信



#### 5.1 直接/间接通信

+ 直接通信方式：发送进程利用操作系统所提供的发送命令直接把消息发送给目标进程。

  通信原语：send、receive

+ 间接通信方式：进程之间的通信需要通过作为某种共享数据结构的实体，该实体用来暂存发送进程发送给目标进程的消息；接收进程则从该实体中取出对方发送给自己的消息。



#### 5.2 消息缓冲队列通信机制

发送进程利用send原语将消息直接发送给接收进程，接收进程则利用receive原语接收消息。

+ 发送原语首先根据发送区a中所设置的消息长度a.size来申请一缓冲区i，接着把发送区a中的信息复制到消息缓冲区i中。为了能将i挂在接收进程的消息队列mq上，应先获得接收进程的内部标识符j，然后将i挂在j.mq上。
+ 接收原语进程调用接收原语receive（b）从自己的消息缓冲队列mq中摘下第一个消息缓冲区i，并将其中的数据复制到以b为首址的指定消息接收区内。



### 6. 死锁

所谓死锁是指在多道程序系统中，一组进程中的每一个进程均**无限期地等待**被该组进程中的另一个进程所占**有且永远不会释放**的资源。

#### 6.1 原因/必要条件

原因：

1. 竞争资源
2. 进程推进顺序不当

**必要条件：**

+ 互斥：一段时间内这个资源只能一个进程使用；
+ 请求和保持：对已获得的资源保持不放；
+ 不剥夺：已获得的资源不能被剥夺；
+ 环路等待：存在一个进程-资源的环形链；

#### 6.2 预防死锁

1. 破坏请求且保持条件：要求进程一次性申请所需要的所有资源；但是这种方法资源浪费严重，并且进程延迟运行。
2. 破坏不剥夺条件：一个已经获取了部分资源的进程，如果新的资源请求不能得到满足，以前的资源都要放弃；但是这种方法复杂，且付出很大的代价，有可能永远没法执行。
3. 破坏环路等待条件：将所有资源按照类型进行线性排队，并赋予不同的序号。所有进程对资源的请求，必须严格按照序号递增的次序提出。这种方法在资源利用率和系统吞吐量上都有显著改善，但是限制了新设备的添加，限制了编程。



#### 6.3 死锁避免

+ 安全状态：是指系统能按某种进程顺序，如<P1，P2，…，Pn>（安全序列），来为每个进程分配其所需资源，直至最大需求，使每个进程都可顺利完成。若系统不存在这样一个安全序列，则称系统处于不安全状态。

  虽然并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进而进入死锁状态。避免死锁的实质在于：**如何避免进入不安全状态。**

+ 银行家算法：

  可用资源向量Available

  最大需求矩阵Max

  分配矩阵Allocation

  需求矩阵Need

  1. 先检查请求是否小于need，超过了认为出错
  2. 检查请求是否小于available，超过表示无足够资源
  3. 系统试探把资源分配给进程，执行安全性检查算法（尽可能去完成资源分配，所有进程都能轮到就是安全的），如果安全完成这次分配，如果不安全则作废。



#### 6.4 死锁检测和恢复

**资源分配图+死锁定理**

在资源分配图中，找出一个既不阻塞又非孤立的进程结点pi，在顺利情况下，pi可获得所需资源而继续执行，直至运行完毕，再释放其所占有的全部资源。这相当于消去pi所有的请求边和分配边，使之成为孤立结点。

**S为死锁状态的充分条件是：当且仅当S状态资源分配图是不可完全简化的。该充分条件称为死锁定理。**

死锁检测算法：

+ 银行家算法中的安全检查方法
+ Warshall的传递闭包算法

**解除死锁：**

+ 剥夺资源，给死锁进程；
+ 撤销进程，回滚；
+ 杀死进程恢复；



### 7. 内存管理

存储管理的任务：

+ 地址转换：逻辑地址到物理地址的转换。

  逻辑地址：用户程序编译后形成的目标代码中出现的地址，一般规定程序的首地址为0，其他指令中的地址部分都是相对于首地址而言的，也就是相对地址。

  物理地址：内存中各存储单元的编号，内存的全部物理单元的集合叫做内存空间，物理空间，绝对空间。

+ 内存的分配和回收：当程序装入内存创建进程的时候，需要向操作系统提出申请分配存储空间。

+ 内存的地址保护：保证各个进程都在自己所属的内存空间中或在公共区域中工作，互不发生干扰。

+ 内存的共享

+ 内存的扩充：虚拟存储概念。

  <img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200720102135385.png" alt="image-20200720102135385" style="zoom:67%;" />

  

#### 7.1 虚拟内存

使用虚拟内存的目的，是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

操作系统将内存抽象成地址空间，每个程序拥有自己的地址空间，这个地址空间被分割成多个页。这些页被映射到物理内存，但不需要是连续的物理内存，也不需要所有页都真实存在物理内存中。当程序用到不存在物理内存的页时，由硬件执行必要的映射，将缺失的部分装入内存并重新执行失败的指令。



#### 7.2 分页/分段/段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统 的共享和保护，又拥有分页系统的虚拟内存功能。

##### 分段 VS 分页

+ 分页透明；分段需要程序显示的划分；
+ 分页时一维地址空间；分段是二维的；
+ 页的大小不可改变；段的大小可动态改变；
+ 分页主要目的是为了实现虚拟内存，获取更大的地址空间；分段主要是为了使程序和数据被划分为逻辑上独立的地址空间并且有助于共享和保护。



#### 7.3 页面置换算法

页面置换算法的主要目的：使页面置换频率最低（缺页率最低）

+ OPT，optimal 最佳：被选择换出的页面时最长时间内不再被访问（两次访问间隔最长），通常可以保证获得最低的缺页率。【理论算法，直击上无法知道哪个页面多长时间不再被访问】
+ LRU，least recently used最近最久没有使用的
+ NRU，not recently used 最近未使用：优先选择已被修改的脏页面（R = 0， M = 1），而不是被频繁使用的干净页面（R = 1， M = 0）
+ FIFO：先进先出
+ 第二次机会算法，FIFO的优化版本：检查最老页面的R位，如果是0表示这个页面又老又没用，可以被置换；否则把它的R位置0，放到队列尾部，使他像是刚刚入队一样。
+ 时钟CLOCK：环形链表，只使用指针指向最老的页面。



















### 8. 设备管理

#### 8.1 磁盘结构

+ 扇面：一个磁盘有多个扇面；

+ 磁道：盘面上的圆形带状区域，一个盘面可以有多个磁道；

+ 扇区：磁道上的一个弧段，一个磁道可以有多个扇区，最小的物理存储单元；

+ 磁头：读写数据；

  

#### 8.2 磁盘调度算法

磁盘调度的主要目标是使磁盘的平均寻道（使磁头移动到适当的磁道上）时间最短。

+ 先来先服务FCFS：公平，但是平均寻道时间可能比较长；
+ 最短寻道时间优先SSTF：优先调度与当前磁头所在位置最近的磁道，这种方法可能会产生饥饿现象；
+ 电梯算法SCAN：总是按照一个方向扫描，直到没有了，掉头。



### 9. Linux进程管理

```bash
# 查看自己的进程
ps -l
# 查看所有进程
ps aux | grep xxx
# 查看端口情况
netstat -anp | grep 8080
```

#### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程就会变成孤儿进程。

孤儿进程会被int进程收养，所以孤儿进程不会对系统造成危害。

#### 僵尸进程

一个子进程的进程描述符在子进程退出的时候不会释放，只有当父进程通过wait或waitpid获取了子进程的信息后才会释放。如果子进程退出，但是父进程没有调用这两个方法，那么子进程的进程描述符还存在系统中，这个进程就是僵尸进程。

系统所能拥有的进程号是有限的，所以大量僵尸进程会对系统造成危害。

要消灭僵尸进程，需要杀死它的父进程，这样僵尸进程变成了孤儿进程，被inti进程收养并释放所有资源，从而结束僵尸进程。



### 网络服务器与分布式系统

