## 深入理解Java虚拟机--JVM

### 第一章：走近java

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200524143731435.png" alt="image-20200524143731435" style="zoom:50%;" />

#### 1.1-1.3 概述 

**java优点：**

+ 结构严谨、面向对象的编程语言；
+ 摆脱硬件平台约束；
+ 相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界；
+ 热点代码检测和运行时编译及优化，越运行性能越好；
+ 一套完善的应用程序接口及第三方类库；

**Java技术体系**（技术服务的领域）：

+ java程序设计语言；
+ 各种硬件平台上的java虚拟机；
+ class文件格式；
+ java API类库；
+ 第三方类库；
+ （广义）clojure、jruby、groovy等运行在Java虚拟机上的语言及其相关程序；

**Java技术体系**（技术关注的业务领域）：

+ java card：applet，小内存设备；
+ java ME（micro edition）：移动终端，精简版；
+ java SE（standard edition）：桌面级应用，标准版；
+ java EE（enterprise edition）：企业应用级，支持多层架构；JDK10之后被oracle放弃，捐献给eclipse，称为jakarta EE。

**JDK vs JRE：**

1. JDK：java development kit 支持java程序开发的最小环境；包括java程序设计语言、java虚拟机和java API类库。
2. JRE：java runtime environment 支持java程序运行的标准环境；包括java API类库中的java SE API和Java虚拟机。

####1.4 java虚拟机家族

虚拟机始祖 sun classic : 只能使用纯解释器方式来执行java代码，如果要使用即时编译器就必须进行外挂，但是外挂了即时编译器，解释器便不能再工作了。**很慢**

exact VM：使用准确式内存管理，能够知道内存中某个位置的数据具体是哪个类型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。这也可以抛弃classic基于句柄的对象查找方式，**减少一次间接查找的开销，显著提升执行性能**。

HotSpot VM：同样使用准确式内存管理、热点探测技术。通过编译器和解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能之间取得平衡。JDK8 之后，融入了JRockit的java mission control监控工具等功能。

mobile/enbedded VM：java ME的虚拟机CDC-HI和CLDC-HI。

BEA JRockit和IBM J9 VM：和hotspot并称三大商业虚拟机。



### 第二章：java内存区域与内存溢出

java程序控制内存的权力交给了虚拟机，一旦出现内存泄漏和溢出方面的问题，排查错误、修正问题就很困难。

#### 2.2 运行时数据区域

> **程序计数器**：program counter register

- 一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器：

1. 线程正在执行Java方法：计数器记录的是正在执行的虚拟机字节码指令的地址；
2. 线程正在执行本地nativ方法：计数器为空undefined；

- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令。每条线程都需要拥有一个独立的程序计数器，互不影响，“线程私有”。没有规定任何outOfMemoryError情况的区域。

  

> **虚拟机栈**：Java Virtual Machine Stack

- 线程私有的，它的生命周期与线程相同。JVM Stack描述的是**Java方法执行的线程内存模型**：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储**局部变量表、操作数栈、动态连接、方法出口**等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
- **局部变量表**存放了编译期可知的各种Java虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double 8个）、**对象引用**和**returnAddress类型**（指向了一条字节码指令的地址）。一般类型占据一个变量槽（slot），64位长度的long和double类型的数据会占用两个变量槽。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。“大小”是指变量槽的数量，每个变量槽的大小由具体的**虚拟机实现**自行决定。
- **两类异常状况**：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。



> **本地方法栈：**native method stack

- 为虚拟机使用到的本地（Native）方法服务（与操作系统有关），类似虚拟机栈。异常也一样。



> **堆：**java heap

- 最大的一块，所有线程共享，在虚拟机**启动时创建**。此内存区域的目的就是**存放对象实例**。
- Java堆是**垃圾收集器**管理的内存区域，因此一些资料中它也被称作“GC堆”（GarbageCollected Heap）。如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程**私有的分配缓冲区**（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。
- Java堆既可以被实现成固定大小的，也可以是可扩展的（主流，通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。



> 方法区：method area

- 各个**线程共享**，它用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。
- 并不等同于“永久代”的概念，只是当时收集器分代设计扩展至方法区，用永久代来实现方法区。JDK6开始放弃永久代，使用本地内存来实现方法区。JDK7把原本放在永久代的**字符串常量池、静态变量**移出；JDK8完全废弃永久代，在本地内存中实现的元空间来代替，把类型信息移到元空间中。
- 该区域的内存回收主要针对常量池回收和类型卸载。
- 如果方法区没有满足内存分配需求，会抛出OutOfMemoryError异常。
  + 运行时常量池runtime constant pool 是方法区的一部分。class文件中的常量池表，存放了编译期生成的各种**字面量和符号引用**，它将在类加载后存在到方法区的运行时常量池中。还会把符号引用翻译出来的**直接引用**也存储在运行时常量池中。具有动态性（运行期也可以将新的常量放入池中）。



> 直接内存 direct memory

直接内存并不是运行时数据区的一部分，但它也被频繁使用，可能导致OutOfMemoryError异常。

JDK4 中的NIO（new input/output）使用一种基于通道channel和缓冲区buffer的IO方式，它可以使用native函数库直接分配堆外内存，通过堆内对象作为堆外内存的引用来进行操作。



#### 2.3 HotSpot虚拟机对象

<u>**对象创建过程：**</u>

虚拟机碰到new指令-- > 检查这个指令的参数能否在常量池中定位到一个类的符号引用 --> 检查这个符号引用代表的类是否已经被加载、解析和初始化过 --> 为对象分配内存（大小已确定） -->  内存空间初始化为零值 --> 对对象设置对象头（object header）--> 执行<init>() 方法（构造函数）初始化

+ 指针碰撞 bump the pointer：Java堆中的内存是规整的，一个指针作为已使用和空闲的分界点，那么分配内存只需要移动这个指针就可以；

+ 空闲列表 free list：java堆中的内存不规整，只能靠维护一个list来记录哪些内存是可用的；

**分配内存的线程安全问题**：

+ 对分配动作同步处理，CAS加上失败重试的方式保证更新操作的原子性；
+ 按照线程划分本地线程分配缓冲（thread local allocation buffer，TLAB），只在属于该线程的缓冲区内分配内存。

<u>**对象内存布局：3部分**</u>

1. **对象头 header** ：包含两类信息
   + 存储对象自身的运行时数据“Mark Word”，32位或者64位：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，该部分信息会根据对象的状态复用自己的存储空间；
   + 类型指针：对象指向它的**类型元数据的指针**，虚拟机通过这个指针来判断该对象是哪个类的实例。但是不是所有的对象都有这个类型指针，查找对象的元数据并不一定要经过对象本身。
2. **实例数据 instance data**：字段的默认存放顺序：相同长度的放在一起，父类在子类之前。

3. **对齐填充 padding** ：占位符，因为虚拟机的自动内存管理系统要求对象的大小都是8字节的整倍数。

<u>**对象的访问定位**：</u>

通过栈上的reference数据来操作堆上的具体对象，两种主流方法：

1. 使用句柄：Java堆中分出一块作为句柄池，reference存储对象的句柄地址，句柄中包含对象实例数据与类型数据各自具体的地址信息；

   句柄优点：reference中是稳定的句柄地址，不需要修改。

2. 直接指针：reference存储的直接是对象地址。

   优点：速度更快。HotSpot主要用的是它！！

+ <u>对象实例数据（堆）:对象中各个实例字段的数据；</u>

- <u>对象类型数据（方法区）：对象的类型、父类、实现的接口、方法等；</u>

#### 2.4 异常

> java堆溢出

通过**内存映像分析工具**对堆转储快照进行分析，第一步确认导致OOM异常的对象是否必要的，也就是区分是内存泄漏还是内存溢出；

1. 内存泄漏：进一步通过工具查看泄漏对象到GC Roots的引用链，定位到对象创建的位置即泄漏产生的具体位置；
2. 内存溢出：检测虚拟机堆参数的设置，再从代码上检查是否不合理。



> 虚拟机栈和本地方法栈溢出

因为HotSpot不支持栈的动态扩展，所以基本只会出现StackOverflowError异常。

无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧无法分配时，HotSpot抛出的都是StackOverflowError异常。线程过多也会造成内存溢出的异常。

这种情况，会有明显的错误堆栈可供分析，容易定位到问题所在。



> 方法区和运行时常量池溢出

JDK6之前，方法区在永久代中：OOM permgen space；

JDK7之后，字符串常量池放在java堆之中；

一个类被回收的条件是比较苛刻的，所以应该特别关注运行时生成大量动态类的应用场景。



> 本机直接内存溢出

直接内存默认情况下和Java堆最大值一样，直接内存溢出的明显特征是在heap dump 文件中不会看见有什么明显的异常情况。



### 第三章：垃圾收集器与内存分配策略

#### 3.1 垃圾收集概述

WHAT？WHEN？HOW？

程序计数器、虚拟机栈、本地方法栈 3个区域生命周期和线程一样，方法结束或者线程结束的时候，内存自然就跟随着回收了。**确定**

Java堆和方法区的回收具有很大的**不确定性**！！重点！！



#### 3.2 对象已死？WHEN

**判断消亡：**

1. 引用计数算法：Java虚拟机并不使用该方法。

   在对象中添加一个引用计数器，每当一个地方引用它时，计数器值就➕1；引用失效时➖1；任何时刻计数器为0的对象都不能再被使用。**该方法不能解决相互循环引用的问题，而且需要配合大量额外处理才能保证正确工作。**

2. 可达性分析算法：reachability analysis

   通过一系列称为**GC Roots的根对象**作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中所走过的路径称为**引用链（reference chain）**。如果某个对象到GC Roots间没有任何引用链相连，即图论意义下的**不可达**，则证明此对象不能再被使用。

   Java技术体系中，**固定的GC Roots对象**包括以下：**（！！非堆中的对象）**

   + 在**虚拟机栈（栈帧中的本地变量表）中引用的对象**，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
   + 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
   + 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
   + 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
   + Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
   + 所有被同步锁（synchronized关键字）持有的对象。
   + 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。



**Java中引用的概念，分为四种，引用强度依次逐渐减弱：**

- **强引用（Strongly Reference）**是最**传统**的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- **软引用（Soft Reference）**是用来描述一些还有用，但**非必须的对象**。只被软引用关联着的对象，在系统将要发生**内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收**，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。
- **弱引用（Weak Reference**）也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象**只能生存到下一次垃圾收集发生为止**。当垃                                                                 　　　　　　            圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。
- **虚引用（Phantom Reference）**也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，**完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例**。为一个对象设置虚引用关联的唯一目的只是为了**能在这个对象被收集器回收时收到一个系统通知**。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。



对象需要**经历两次标记过程**才真正死亡：

1. 第一次标记：可达性分析 --> 不可达；

2. 第二次标记：

   ```javascript
   if( 对象没有覆盖finalize()方法 || finalize()方法已经被虚拟机调用过 ){ 
     //“没有必要执行” 
   } else {
     //该对象将会被放置在一个名为F-Queue的队列之中,稍后由一条Finalizer线程去触发它们的finalize()方法。
     //稍后收集器将对F-Queue中的对象进行第二次小规模的标记
   }
   ```



**回收方法区**：

方法区的垃圾回收行为很少，甚至没有（JDK11未实现方法区类型卸载的收集器），性价比较低。

主要回收两部分内容：**废弃的常量和不再使用的类型**：

回收废弃常量与回收Java堆中的对象非常类似。**已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。**如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。

**类型是否属于“不再被使用的类”**需要同时满足下面三个条件：

1. 该类**所有的实例都已经被回收**，也就是Java堆中不存在该类及其任何派生子类的实例。
2. **加载该类的类加载器**已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
3. 该**类对应的java.lang.Class对象**没有在任何地方被引用，无法在任何地方通过**反射**访问该类的方法。

Java虚拟机**被允许(但不一定)**对满足上述三个条件的无用类进行回收。在大量使用**反射、动态代理、CGLib等字节码框架**，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。



#### 3.3 垃圾收集算法

垃圾收集算法可以划分为**“引用计数式垃圾收集”（Reference Counting GC，直接垃圾收集）**和**“追踪式垃圾收集”（Tracing GC，间接垃圾收集）**。下面都是追踪式垃圾收集的内容。

> **分代收集（Generational Collection）理论**：

**理论基础**：（主要是前两个假说）

1. **弱分代假说**（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
2. **强分代假说**（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说（Intergenerational Reference Hypothesis，由1，2得到）：跨代引用相对于同代引用来说仅占极少数。

**设计原则：**收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。一般至少会把Java堆划分为**新生代**和**老年代**两个区域。

分代收集存在的明显困难：对象不是孤立的，对象之间会存在跨代引用。因此需要在新生代上建立一个全局的数据结构“记忆集”（Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。

> 标记-清除算法（Mark-Sweep）

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

**缺点：**

1. 执行效率不稳定：如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；
2. 内存空间的碎片化问题：空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。



> 标记-复制算法

“半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

现在的商用Java虚拟机大多都优先采用了这种收集算法去回收**新生代（老年代一般不使用）**。**实际上并不是按照半区来划分--appel式回收。**

**Appel式回收**的具体做法是把新生代分为**一块较大的Eden空间（HotSpot虚拟机默认80%）和两块较小的Survivor空间（10%）**，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。

**“逃生门”的安全设计**：当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行**分配担保（Handle Promotion）**。

**优点：**

1. 分配内存时不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。实现简单，运行高效。

**缺点：**

1. 内存中存活率较高时，会产生大量的内存间复制的开销
2. 将可用内存缩小为了原来的一半，空间浪费。



> 标记-整理算法（Mark-Compact）

标记之后，让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

优点：

1. 不存在空间碎片化导致的问题；
2. 有利于吞吐量提高；

**缺点：**

1. 尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作。

   

#### 3.4 HotSpot的算法细节实现

> 根节点枚举：可达性分析算法中从GC Roots集合找引用链中的关键细节

固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。**迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，以保证一致性。**

由于目前主流Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿之后，虚拟机应当是有办法直接得到哪些地方存放着对象引用的——**比如在HotSpot中使用OopMap（普通对象指针 Ordinary Object Pointer，OOP）的数据结构**，并不需要一个不漏地检查完所有执行上下文和全局的引用位置。



> 安全点

HotSpot只在特定的位置，即**安全点（Safepoint）**上生成OopMap。因此用户程序执行时强制要求必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。例如具有**方法调用、循环跳转、异常跳转**等指令序列复用功能的地方才会产生安全点。

如何让所有线程都跑到最近的安全点：

1. **抢先式中断（Preemptive Suspension）**：不需要线程的执行代码主动去配合；在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。

2. **主动式中断（Voluntary Suspension）**：当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地**设置一个标志位**。**各个线程执行过程时会不停地主动去轮询这个标志**，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

   **轮询：**HotSpot使用**内存保护陷阱**的方式，把轮询操作精简至只有一条汇编指令的程度。



> 安全区域

程序没有分配处理器时间（线程处于Sleep状态/Blocked状态），这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。

**安全区域（Safe Region）**：指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。



> 记忆集与卡表

**记忆集（Remembered Set）**：一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。为解决涉及部分区域收集（Partial GC）行为、对象跨代引用所带来的问题。

**记录精度：**

1. 字长精度：每个记录精确到**一个机器字长**（就是处理器的寻址位数），该字包含跨代指针;
2. 对象精度：每个记录精确到一个**对象**，该对象里有字段含有跨代指针;
3. **卡精度（卡表，Card Table）**：每个记录精确到一块**内存区域**，该区域内有对象含有跨代指针。

卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。HotSpot虚拟机的卡表是一个字节数组。只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。



> 写屏障

**写屏障（Write Barrier）**：HotSpot虚拟机维护卡表状态的技术，属于机器码层面。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，**赋值的前后都在写屏障的覆盖范畴内**。

在赋值前的部分的写屏障叫作**写前屏障（Pre-Write Barrier**），在赋值后的则叫作**写后屏障（Post-Write Barrier）**。

**“伪共享”（False Sharing）问题**：高并发情况下，不同线程更新的对象正好都处于某块内存区域内，就会导致更新卡表时正好**写入同一个缓存行**而影响性能。为了避免伪共享问题，卡表更新前先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。



> 并发的可达性分析

并发的扫描可能会发生对象的消失问题，可能的情况有两种：

1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

两种解决方案：

1. 增量更新（Incremental Update）：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。**已扫描标记为未扫描完全**
2. 原始快照（Snapshot At TheBeginning，SATB）：就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。



#### 3.5 经典垃圾收集器

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200310153243280.png" alt="image-20200310153243280" style="zoom:50%;" />



> Serial收集器

单线程工作的收集器，在它进行垃圾收集时，必须暂停其他所有工作线程。是HotSpot虚拟机运行在**客户端**模式下的**默认新生代收集器**。

优点：简单而高效；是所有收集器里额外内存消耗最小的；适合单核处理器或处理器核心数较少的环境。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200310153432331.png" alt="image-20200310153432331" style="zoom:50%;" />



> ParNew收集

ParNew收集器实质上是Serial收集器的**多线程并行版本**，其他行为和serial一模一样。CMS的出现巩固了它的地位！

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200310154029127.png" alt="image-20200310154029127" style="zoom:50%;" />

> Parallel Scavenge 收集器

同样是基于标记-复制算法实现，也能够并行收集的多线程收集器。**Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。**主要适合在后台运算而不需要太多交互的分析任务。

> Serial Old收集器

Serial Old是Serial收集器的老年代版本，**单线程**，使用**标记-整理算法**。

> Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，**多线程并发，基于标记-整理算法**。JDK 6时才开始提供。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200310155145709.png" alt="image-20200310155145709" style="zoom:50%;" />



> CMS收集器：并发低停顿收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取**最短回收停顿时间为目标**的收集，基于标记-清除算法。

1. 初始标记（CMS initial mark）：暂停应用线程，标记GC Roots**直接关联**的对象，速度很快；
2. 并发标记（CMS concurrent mark）：从GC Roots的直接关联对象开始**遍历**整个对象图的过程；
3. 重新标记（CMS remark）：暂停应用线程，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；**使用增量更新！**
4. 并发清除（CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

**缺点**：

- 对处理器资源非常敏感：CMS默认启动的回收线程数是**（处理器核心数量+3）/4**。如果处理器核心数不足4个，CMS会导致用户线程速度大幅下降。
- 无法处理“浮动垃圾”（Floating Garbage）：一部分垃圾对象是出现在标记过程结束以后，只好留待下一次垃圾收集时再清理掉。这可能会导致CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），从而启用Serial Old收集器来重新进行老年代的垃圾收集（full GC）。
- 有大量空间碎片产生。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200310155418387.png" alt="image-20200310155418387" style="zoom:50%;" />



> Garbage First收集器

G1收集器，开创了收集器**面向局部收集**的设计思路和**基于Region的内存布局**形式。主要面向**服务端应用**的“全功能的垃圾收集器”（Fully-Featured GarbageCollector）。**目标是在延迟可控的情况下获得尽可能高的吞吐量。**

**停顿时间模型（Pause Prediction Model）**：在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒。

**面向局部收集**（Mixed GC模式）：它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，不管分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。

**基于Region的内存布局**：把连续的Java堆划分为多个大小相等的独立区域（Region），新生代和老年代成为一系列区域的动态集合。Region中的**Humongous区域**，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。

G1收集的4个步骤：

1. 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
2. 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。
3. 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
4. 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把**决定回收的那一部分Region的存活对象复制到空的Region中**，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

<u>*细节问题：*</u>

1. G1的记忆集在存储结构的本质上是一种**哈希表**，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。所以G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。
2. G1收集器则是通过原始快照（SATB）算法来实现的最终标记的。G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，**把Region中的一部分空间划分出来用于并发回收过程中的新对象分配**，并发回收时新分配的对象地址都必须要在这两个指针位置以上（即注定不需要回收的区域）。
3. **停顿预测模型**是以**衰减均值（Decaying Average，“最近的”平均状态）**为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。停顿默认200ms。

<u>*G1和CMS对比：*</u>

G1的优点：可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集；从整体来看是基于“标记-整理”算法，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现；

G1的缺点：G1无论是为了垃圾收集产生的**内存占用（Footprint）**还是程序运行时的**额外执行负载（Overload）**都要比CMS要高；

G1的原始快照比增量更新能减少并发标记和重新标记阶段的消耗，但是G1对写屏障的复杂操作要比CMS消耗更多的运算资源；

实践经验，目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间。



#### 3.6 低延迟垃圾收集器

衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”。其中**低延迟**的重要性日益突出，因为其他两个都能从硬件性能方面进行改善。

Shenandoah和ZGC，几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿。



> Shenandoah

Shenandoah是一款只有OpenJDK才会包含，而OracleJDK里反而不存在的收集器。

**目标：**实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器，该目标意味着相比CMS和G1，Shenandoah不仅要**进行并发的垃圾标记**，还要**并发地进行对象清理后的整理动作**。

**Shenandoah区别于G1的三大特征：**

1. 支持并发的整理算法；
2. 默认不使用分代收集的；
3. 摒弃记忆集，改用连接矩阵（Connection Matrix）的全局数据结构来记录跨Region的引用关系。

**Shenandoah的步骤：▲停顿  △并发**

1. ▲初始标记（Initial Marking）：标记与GC Roots直接关联的对象，停顿；
2. △并发标记（Concurrent Marking）：遍历对象图，标记出全部可达的对象，并发；
3. ▲最终标记（Final Marking）：处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。短暂的停顿；
4. △并发清理（Concurrent Cleanup）：清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。
5. △并发回收（Concurrent Evacuation）：**并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异**。把回收集里面的存活对象先复制一份到其他未被使用的Region之中。**Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决并发问题**。
6. ▲初始引用更新（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为**引用更新**。设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。非常短暂的停顿。
7. △并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，并发；并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
8. ▲最终引用更新（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GCRoots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。
9. △并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。

**并行整理核心 ：Brooks Pointer**

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200312125651583.png" alt="image-20200312125651583" style="zoom:50%;" />

Brooks Pointer是一种转发指针，在原有对象布局结构的最前面（header前）统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。虽然每次对象访问会带来一次额外的转向开销，但是比内存保护陷阱的方式要好很多。

Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性的。



> ZGC：Z garbage collector

ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。但是实现思路不一样。

ZGC收集器是一款基于Region内存布局的（即page或者Zpage），（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

ZGC限制了它能承受的对象分配速率不会太高；ZGC还有一个常在技术资料上被提及的优点是支持“NUMA-Aware”的内存分配。NUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种为多处理器或者多核处理器的计算机所设计的内存架构。

**Zpage具有动态性**——动态创建和销毁，以及动态的区域容量大小：

- 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。
- 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。
- 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。**每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配**（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段，稍后会介绍到）的，因为复制一个大对象的代价非常高昂。

**并发整理算法的实现关键**：

+ 染色指针（Colored Pointer）：一种直接将少量额外的信息存储在指针上的技术；

  将指针的高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到；

  **缺点：**有4TB的内存限制，不能支持32位平台，不能支持压缩指针；

  **优点：**①染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理；②染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量（因为没有卡表没有用到写屏障）；③染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。

+ 读屏障

**ZGC实现步骤：**

1. 并发标记（Concurrent Mark）：与G1、Shenandoah类似，会有初始标记、最终标记的短暂停顿。**与G1、Shenandoah不同的是，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位**。

2. 并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成**重分配集（Relocation Set）**。

   *** **重分配集与G1收集器的回收集还是有区别的，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。

   此外，在JDK 12的ZGC中开始支持的**类卸载以及弱引用的处理**，也是在这个阶段中完成的。

3. 并发重分配（Concurrent Relocate，核心阶段）：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。

   **指针的自愈（Self-Healing）能力**：如果用户线程此时并发访问了位于重分配集中的对象（通过染色指针来判断），这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。即只有第一次访问旧对象会陷入转发。

4. 并发重映射（Concurrent Remap）：重映射所做的就是**修正整个堆中指向重分配集中旧对象的所有引用**。但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因此，ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的。



#### 3.7 选择合适的垃圾收集器

> Epsilon收集器

Epsilon实际上是一个**自动内存管理子系统**，

一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负责堆的管理与布局、对象的分配、与解释器的协作、与编译器的协作、与监控子系统协作等职责，其中至少堆的管理和对象的分配这部分功能是Java虚拟机能够正常运作的必要支持，是一个最小化功能的垃圾收集器也必须实现的内容。

如果读者的应用只要运行数分钟甚至数秒，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。

> 收集器的权衡

收集器的权衡主要考虑以下三个问题：

1. 应用程序的主要关注点是什么？

   如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那**吞吐量**就是主要关注点；如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样**延迟**就是主要关注点；而如果是客户端应用或者嵌入式应用，那垃圾收集的**内存占用**则是不可忽视的。

2. 运行应用的基础设施如何？

   譬如硬件规格，要涉及的系统架构是x86-32/64、SPARC还是ARM/Aarch64；处理器的数量多少，分配内存的大小；选择的操作系统是Linux、Solaris还是Windows等。

3. 使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？

> GC日志



#### 3.8 内存分配回收策略

java自动花内存管理的根本，在于自动化内存分配和自动回收分配的内存。

**收集器日志**：在虚拟机发生垃圾回收行为的时候打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。

1. 大多数情况下，**对象在新生代Eden区中分配**。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。如果这次回收发现Survivor空间不够放存活的对象，则通过分配担保机制提前转移到老年代去。
2. **大对象可以直接进入老年代**，因为大对象分配空间容易触发垃圾回收，或者产生巨大的复制开销；-XX：PretenureSizeThreshold进入老年代的大小阈值可调
3. **长期存活的对象将进入老年**，-XX：MaxTenuringThreshold进入老年代的年龄阈值可以调整；
4. HotSpot虚拟机并不是永远要求对象的年龄必须达到年龄阈值才能晋升老年代，**如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。**



### 第四章 虚拟机性能监控/故障处理工具

#### 4.2 基础故障处理工具

JDK自带工具，主要是用于监视虚拟机运行状态和进行故障处理：

- 商业授权工具：主要是JMC（Java Mission Control）及它要使用到的JFR（Java FlightRecorder），JMC这个原本来自于JRockit的运维监控套件从JDK 7 Update 40开始就被集成到OracleJDK中，JDK 11之前都无须独立下载，但是在商业环境中使用它则是要付费的。
- 正式支持工具：这一类工具属于被长期支持的工具，不同平台、不同版本的JDK之间，这类工具可能会略有差异，但是不会出现某一个工具突然消失的情况。
- 实验性工具：这一类工具在它们的使用说明中被声明为“没有技术支持，并且是实验性质的”（Unsupported and Experimental）产品，日后可能会转正，也可能会在某个JDK版本中无声无息地消失。但事实上它们通常都非常稳定而且功能强大，也能在处理应用程序性能问题、定位故障时发挥很大的作用。

> jps：虚拟机进程状况工具（JVM Process Status Tool）

可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。

```
jps [option] [hostid]
```

> jstat：虚拟机统计信息监视工具（JVM Statistics Monitoring Tool）

是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程[插图]虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。



### 第五章：调优案例与实战



### 第六章：类文件结构

把我们编写的程序编译成二进制本地**机器码（Native Code）**已不再是唯一的选择，越来越多的程序语言选择了**与操作系统和机器指令集无关的、平台中立的格式（字节码，ByteCode）**作为程序编译后的存储格式。

#### 6.2 无关性的基石--字节码（ByteCode）

+ 平台无关性：各种不同平台的Java虚拟机，以及所有平台都统一支持字节码的程序存储格式；
+ 语言无关性：除了java语言，其他语言也可以运行于java虚拟机上。

实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。



#### 6.3 class类文件的结构

Class文件是**一组以8个字节为基础单位的二进制流**，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。

只有两种数据类型：“无符号数”和“表”

- 无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值；u4就表示4字节无符号数
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，表用于描述有层次关系的复合结构的数据；**class文件本质上也是一张表**。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200314165815175.png" alt="image-20200314165815175" style="zoom:50%;" />



**魔数（Magic Number）**：它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。值为0xCAFEBABE（咖啡宝贝？？？）。

**Class文件的版本号**：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。虚拟机也必须拒绝执行超过其版本号的Class文件。编号从45开始，JDK6对应的版本号是50。JDK1.2之后几乎没有使用过。

**常量池容量计数值（constant_pool_count）**：**从1而不是0开始的**【eg. 常量池容量0x0016，即22，这就代表常量池中有21项常量，索引值范围为1～21】如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。

**常量池**：Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一。**主要存放两大类常量：字面量（Literal）和符号引用（SymbolicReferences）。**

- 字面量比较接近于Java语言层面的常量概念，如**文本字符串、被声明为final的常量值**等。

- 符号引用则属于编译原理方面的概念，主要包括下面几类常量：

  - 被模块导出或者开放的包（Package）
  - 类和接口的全限定名（Fully Qualified Name）
  - 字段的名称和描述符（Descriptor）
  - 方法的名称和描述符
  - 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
  - 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

  常量池中每一项常量都是一个表，共有17种结构各不相同的表结构数据。这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位tag；

  <img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200314173921469.png" alt="image-20200314173921469" style="zoom:50%;" />

**访问标志（access_flags）**：这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final。

**类索引（this_class）**：类索引用于确定这个类的全限定名；

**父类索引（super_class）**：父类索引用于确定这个类的父类的全限定名；

**接口数量（interface_count）**：表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0；

**接口索引集合（interfaces）**：是一组u2类型的数据的集合，用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。

**字段表（field_info）：**用于描述接口或者类中声明的变量。“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。access_flags字段修饰符；name_index字段的简单名，和descriptor_index字段和方法的描述符（都是对常量池项的引用）;属性表集合（可能存在），用于存储一些额外的信息。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200319152148551.png" alt="image-20200319152148551" style="zoom:50%;" />

> 简单名称：myfield；mymethod；
>
> 描述符：描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte-B、char-C、double-D、float-F、int-I、long-J、short-S、boolean-Z）以及代表无返回值的void-V类型都用一个大写字符来表示，而对象类型则用字符L+全限定名来表示Ljava/lang/object；数组类型，每一维度将使用一个前置的“[”字符来描述.
>
> 用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内
>
> 全限定名：org/fenixsoft/clazz/TestClass

*字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。*

**方法表（method_info）**：格式类似字段表集合；不同：synchronized、native、strictfp和abstract关键字可以修饰方法。而方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面。

<u>在Java语言中</u>，要重载（Overload）一个方法，除了要与原方法具有<u>相同的简单名称</u>之外，还要求必须拥有一个与原方法<u>不同的特征签名</u>。**特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，**也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。

但是<u>在Class文件格式之中</u>，特征签名的范围明显要更大一些，只要<u>描述符不是完全一致的两个方法就可以共存</u>。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

**属性表（attribute_info）**：java虚拟机定义了29种属性，名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200319155453845.png" alt="image-20200319155453845" style="zoom:50%;" />

1. **code属性**：出现在**方法表的属性集合**之中，存放方法中的具体内容。但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。

   code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。每个指令就是一个u1类型的单字节。

   Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据

2. **Exceptions属性**：列举出方法中可能抛出的受查异常（Checked Excepitons）。

3. **LineNumberTable属性**：描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。作用：当抛出异常时，堆栈中会显示出错的行号。

4. **LocalVariableTable及LocalVariableTypeTable属性**：描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系；当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名

5. **SourceFile及SourceDebugExtension属性**：

6. **ConstantValue属性**：

7. **InnerClasses属性**：

8. **Deprecated及Synthetic属性**：

9. **StackMapTable属性**：

10. **Signature属性**：

11. **BootstrapMethods属性**：

12. **MethodParameters属性**：

13. **模块化相关属性**：

14. **运行时注解相关属性**：



#### 6.4 字节码指令简介

指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。

Java虚拟机采用**面向操作数栈**而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。

- **优点**：放弃了操作数长度对齐，可以省略掉大量的填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。

- **缺点**：指令集的操作码总数不能够超过256条；由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构。

Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会被故意设计成非完全独立的。大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。**这些操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的**。

**指令分为九大类**：

1. **加载和存储指令**：用于将数据在栈帧中的局部变量表和操作数栈之间来回传输；

   + 将一个局部变量加载到操作栈：load；
   + 将一个数值从操作数栈存储到局部变量表：store；
   + 将一个常量加载到操作数栈：push、const
   + 扩充局部变量表的访问索引的指令：wide

2. **运算指令**：用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶；

   加法add；减法sub；乘法mul；除法div；求余rem；取反neg；位移shl、shr、ushr；按位或/与/异或指令：or/and/xor；局部变量自增指令：inc；比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp

3. **类型转换指令**：将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。

4. **对象创建与访问指令**：类实例：new；数组：newarray、anewarray、multianewarray。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：

   - 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic
   - 把一个数组元素加载到操作数栈的指令：aload
   - 将一个操作数栈的值储存到数组元素中的指令：astore
   - 取数组长度的指令：arraylength
   - 检查类实例类型的指令：instanceof、checkcast

5. **操作数栈管理指令**：

   - 将操作数栈的栈顶一个或两个元素出栈：pop、pop2
   - 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2
   - 将栈最顶端的两个数值互换：swap

6. **控制转移指令**：可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序：

   - 条件分支
   - 复合条件分支：tableswitch、lookupswitch
   - 无条件分支：goto、goto_w、jsr、jsr_w、ret

7. **方法调用和返回指令**：

   - invokevirtual指令：用于**调用对象的实例方法**，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。
   - invokeinterface指令：用于**调用接口方法**，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
   - invokespecial指令：用于**调用一些需要特殊处理的实例方法**，包括实例初始化方法、私有方法和父类方法。
   - invokestatic指令：用于**调用类静态方法（static方法）**。
   - invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

8. **异常处理指令**：显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。

   而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成。

9. **同步指令**：方法同步是隐式的，方法内部同步块有指令monitorenter/monitorexit。



### 第七章：虚拟机类加载机制

虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？

**虚拟机的类加载机制：**Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行**校验、转换解析和初始化**，最终形成可以被虚拟机直接使用的Java类型。

#### 7.2 类加载时机

**类型的整个生命周期**：

1. 加载（Loading）
2. 验证（Verification）
3. 准备（Preparation）
4. 解析（Resolution）
5. 初始化（Initialization）
6. 使用（Using）
7. 卸载（Unloading）

其中验证、准备、解析三个部分统称为连接（Linking）。加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，而解析阶段不一定，可能在初始化之后再进行（**动态绑定**）。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200319193454412.png" alt="image-20200319193454412" style="zoom:50%;" />



**六种情况必须立即对类进行“初始化”：**

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令。
   - 使用new关键字实例化对象的时候。
   - 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
   - 调用一个类型的静态方法的时候。
2. 使用java.lang.reflect包的方法对类型进行**反射调用**的时候。
3. 当初始化类的时候，如果发现其**父类**还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的**主类**（包含main()方法的那个类），虚拟机会先初始化这个主类。
5. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial**四种类型的方法句柄**，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。



#### 7.3 类加载过程

1. **加载 Loading**

   在加载阶段，Java虚拟机需要完成以下三件事情：

   + 通过一个类的全限定名来获取定义此类的二进制字节流。
   + 将这个字节流所代表的静态存储结构转化为**方法区的运行时数据结构**。（方法区中的数据存储格式完全由虚拟机实现自行定义）
   + 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

   **从哪里获取**？如何获取？

   + 压缩包：war/jar
   + 网络中：web applet
   + 运行时计算生成：动态代理技术
   + 由其他文件生成：JSP =>Class文件
   + 从数据库中读取；可以从加密文件中获取

   **非数组类型**的loading加载，是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的**引导类加载器**来完成，也可以由用户自定义的类加载器去完成。

   **数组类**本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）还是要靠类加载器来完成加载。

   + 如果数组C的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。
   + 如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。
   + 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。

2. **验证Verification**

   **目的**：确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

   验证阶段大致上会完成下面四个阶段的检验动作：

   - 文件格式验证：保证输入的字节流能正确地解析并存储于方法区之内（能被当前版本的虚拟机处理），格式上符合描述一个Java类型信息的要求（符合Class文件格式的规范）。这阶段的验证是**基于二进制字节流**进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。
   - 元数据验证：对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。
   - 字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的，即对方法体（code属性）进行校验。后来，字节码验证的类型推导转变为类型检查（使用stackMapTable）。
   - 符号引用验证：虚拟机将符号引用转化为直接引用的时候（即解析阶段）才进行符号引用验证。它是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，**该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源**。

3. **准备Preparation**

   为**类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段**，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 8及之后，类变量会存放在Java堆中。

   1. 这时候进行内存分配的仅包括**类变量**，而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在Java堆中。
   2. 这里所说的初始值“通常情况”下是数据类型的零值，赋值动作要到类的初始化阶段才会被执行。如果类字段的字段属性表中存在ConstantValue属性（final），那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值

4. **解析Resolution**

   解析：**Java虚拟机将常量池内的符号引用替换为直接引用的过程**。解析阶段发生的具体时间不一定，执行用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析；对方法或者字段的访问之前，也会在解析阶段中对它们的可访问性（public、protected、private、<package>）进行检查。

   > 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。
   >
   > 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

   解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用。

   - 类或接口的解析：
   - 字段解析：
   - 方法解析：
   - 接口方法解析：

5. **初始化initialization**

   初始化阶段就是执行类构造器`<clinit>()`方法的过程。`<clinit>()`并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物，由编译器自动收集类中的所有**类变量的赋值动作和静态语句块（static{}块）中的语句**合并产生的。

   + 编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
   + Java虚拟机会保证在子类的`<clinit>()`方法执行前，父类的`<clinit>()`方法已经执行完毕。因此在Java虚拟机中第一个被执行的`<clinit>()`方法的类型肯定是java.lang.Object。
   + 如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。**所以类和接口中可能有，也可能没有**。
   + 接口与类不同的是，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。
   + Java虚拟机必须保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁同步。



#### 7.4 类加载器

类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为**“类加载器”（Class Loader）**。

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的**唯一性**，每一个类加载器，都拥有一个独立的类名称空间。

1. **启动类/引导类加载器（Bootstrap ClassLoader）**：使用C++语言实现，是虚拟机自身的一部分；
2. **其他所有的类加载器/自定义类加载器（User-Defined ClassLoader）**：这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。

**Java一直保持着三层类加载器、双亲委派的类加载架构**：

1. **启动类加载器（Bootstrap Class Loader）**：负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（.jar）类库加载到虚拟机的内存中。**启动类加载器无法被Java程序直接引用**，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。

   ```java
   // 获取启动类加载器能够加载的路径
   URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
   Classloader classloader = Provider.class.getClassLoader();
   // 获取扩展类加载器的加载路径
   String extDirs = System.getProperty("java.ext.dirs");
   ```

   

2. **扩展类加载器（Extension Class Loader）**：在类sun.misc.Launcher$ExtClassLoader（Launcher的内部类）中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。

3. **应用程序类加载器（Application Class Loader）**：由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为**“系统类加载器”**。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。

   <img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200407100357517.png" alt="image-20200407100357517" style="zoom:40%;" />

各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型（Parents Delegation Model）**”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般**不是以继承（Inheritance）的关系来实现**的，而是通常使用**组合（Composition，包含）关系**来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

e.g. 用户自定义类，默认使用系统类加载器；String类（Java的核心类库）使用引导类加载器进行加载。

Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系

**破坏双亲委派模型**：

1. JDK 1.2之前，自定义类加载器重写了`loadClass()` 方法，可能会导致双亲委派模型的破坏；JDK 1.2之后重写`findClass()`，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。
2. 第二次“被破坏”是由这个**模型自身的缺陷**导致的：如果有基础类型又要调用回用户的代码，会导致一种父类加载器去请求子类加载器完成类加载的行为。
3. 第三次“被破坏”是由于用户对程序动态性（例如，热部署）的追求而导致的，OSGi（开放服务网关协议，Open Service Gateway Initiative，Java动态化模块化系统的一系列规范）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。



#### 7.5 Java模块化系统

**Java模块化系统（Java Platform Module System，JPMS）**：JDK9引入，为了实现**可配置的封装隔离机制**。解决了原来的问题：

1. 基于类路径（ClassPath）来查找依赖缺乏可靠性，模块化封装可以在启动时就检验依赖关系的完备性，而不必等到运行时。
2. 原来类路径上跨JAR文件的public类型的可访问性问题，模块提供了更精细的可访问性控制。

Java的模块定义还包含以下内容：

+ 依赖其他模块的列表。
+ 导出的包列表，即其他模块可以使用的列表。
+ 开放的包列表，即其他模块可反射访问模块的列表。
+ 使用的服务列表。
+ 提供服务的实现列表。

**“模块路径”（ModulePath）的概念**：只有放在模块路径上的jar包，才会被当作模块来对待。

模块化下的类加载器：

1. 扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。
2. 平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。
3. 启动类加载器现在是在Java虚拟机内部和Java类库共同协作实现的类加载器，尽管有了BootClassLoader这样的Java类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景（譬如Object.class.getClassLoader()）中仍然会返回null来代替，而不会得到BootClassLoader的实例。
4. 当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200408105953099.png" alt="image-20200408105953099" style="zoom:40%;" />



### 第八章：JVM字节码执行引擎

**执行引擎**是Java虚拟机核心的组成部分之一

**Java虚拟机字节码执行引擎的概念模型**：

+ 输入：字节码二进制流；
+ 处理：通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎；
+ 输出：执行结果。



#### 8.2 运行时栈帧结构

**方法**：最基本的执行单元

**栈帧（Stack Frame）**：用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（VirtualMachine Stack）的栈元素。

栈帧存储了方法的**局部变量表、操作数栈、动态连接和方法返回地址**等信息，

每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200408112233478.png" alt="image-20200408112233478" style="zoom:50%;" />

**局部变量表（Local Variables Table）**：一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。

编译时，在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。局部变量表的容量以变量槽（Variable Slot）为最小单位，变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化。变量槽可复用。

索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果执行的是<u>实例方法</u>，那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽。

**操作数栈（Operand Stack）**：操作栈，它是一个后入先出（Last In First Out，LIFO）栈。

操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在**编译**程序代码的时候，编译器必须要严格保证这一点，在**类校验**阶段的数据流分析中还要再次验证这一点。

另外在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，**令两个栈帧出现一部分重叠**。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。

**动态连接（Dynamic Linking）**：为了支持方法调用过程中的动态连接，每个栈帧都包含**一个指向运行时常量池中该栈帧所属方法的引用**。

Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为**静态解析**。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为**动态连接**。

**方法返回地址**：两种方式退出这个方法：

1. **“正常调用完成”**（Normal Method Invocation Completion）：执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。**主调方法的PC计数器的值**就可以作为返回地址，栈帧中很可能会保存这个计数器值。
2. **“异常调用完成“**（AbruptMethod Invocation Completion）：在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理，就会导致方法退出。这时不会给它的上层调用者提供任何返回值。返回地址是要通过**异常处理器表**来确定的，栈帧中就一般不会保存这部分信息。



#### 8.3 方法调用

方法调用阶段唯一的任务就是**确定被调用方法的版本**（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。

调用不同的方法，有5种指令：

+ invokestatic：用于调用静态方法。
+ invokespecial：用于调用实例构造器<init>()方法、私有方法和父类中的方法。
+ invokevirtual：用于调用所有的虚方法。
+ invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象。
+ invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。

**解析调用**：一定是个静态的过程，在**编译期间就完全确定**，在**类加载的解析阶段**就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。

+ **“非虚方法”（Non-Virtual Method）**：会在类加载的时候就可以把符号引用解析为该方法的直接引用，静态方法、私有方法、实例构造器、父类方法（被invokestatic和invokespecial指令调用）、被final修饰的方法（尽管它使用invokevirtual指令调用）。

**分派（Dispatch）调用**：

+ “静态类型”（StaticType）/ “外观类型”（Apparent Type）：“Human”，静态类型是在编译期可知的；

  “实际类型”（Actual Type）/ “运行时类型”（Runtime Type）：“Man”，实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

+ **1. 静态分派 --> 重载**：所有**依赖静态类型**来决定方法执行版本的分派动作，都称为静态分派。发生在**编译阶段**，因此确定静态分派的动作实际上不是由虚拟机来执行的，这点也是为何一些资料选择把它归入“解析”而不是“分派”的原因。所以在编译阶段，Javac编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。

+ **2.动态分派 --> 重写/多态**：在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。这种多态性的根源在于虚方法调用指令invokevirtual的执行逻辑，该指令执行的第一步就是在运行期确定接收者的**实际类型**，自下往上向父类进行查找。

+ **3.单分派与多分派**：方法的**接收者**与方法的**参数**统称为方法的**宗量**。**单分派**是根据**一个宗量**对目标方法进行选择，**多分派**则是根据**多于一个宗量**对目标方法进行选择。

  静态分派属于多分派类型；动态分派属于单分派类型。



#### 8.4 动态类型语言支持 -- invokedynamic

**动态类型语言**：关键特征是它的类型检查的主体过程是在**运行期**而不是编译期进行的。与动态语言、弱类型语言并不是一个概念。编译器在编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定），即“变量无类型而变量值才有类型”。

<u>**方法句柄（Method Handle）**</u>

JDK 7时新加入的java.lang.invoke包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供**一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）**。在拥有方法句柄之后，Java语言也可以拥有类似于**函数指针**或者委托的方法别名这样的工具了。

```java
// classA 有一个printLn方法
public static void main(String[] args) throws Throwable {
  Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new classA();
  getPrintLnMH(obj).ivokeExact("icyfenix");
}

private statis MethodHandle getPrintLnMH(Object reveiver) throws Throwable {
  // MethodType方法类型，包含了方法的返回值和具体参数
  MethodType mt = MethodType.methodType(void.class, String.class);
  //lookup()方法可以在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄
  //这里根据 名称：printLn 方法类型：mt查找，并且绑定方法的接受者，也即this指向的对象，方法的第一个隐式参数
  return lookup().findVirtual(reveiver.getClass(),"printLn", mt).bindTo(reveiver);
}
```

**MethodHandle与Reflection都是在模拟方法调用，但是区别在于：**

1. Reflection是在模拟Java代码层次的方法调用；而MethodHandle是在模拟字节码层次的方法调用。在MethodHandles.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual（以及invokeinterface）和invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。
2. Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅包含执行该方法的相关信息。
3. 由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还在继续完善中），而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。
4. Reflection API的设计目标是只为Java语言服务的，而MethodHandle则设计为可服务于所有Java虚拟机之上的语言，其中也包括了Java语言而已。



**<u>invokedynamic指令</u>**

某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条invoke*指令方法分派规则完全固化在虚拟机之中的问题，把**如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中**，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。

每一处含有invokedynamic指令的位置都被称作**“动态调用点（Dynamically-Computed CallSite）”**。

invokedynamic的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为**CONSTANT_InvokeDynamic_info常量**，从这个新常量中可以得到3项信息：

+ 引导方法（Bootstrap Method，该方法存放在新增的BootstrapMethods属性中），返回java.lang.invoke.CallSite对象；
+ 方法类型（MethodType）；
+ 名称；



#### 8.5 基于栈的字节码解释执行引擎

虚拟机是如何执行方法里面的字节码指令的：**在概念模型下**的Java虚拟机解释执行字节码时，其执行引擎是如何工作的。

<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200411111357859.png" alt="image-20200411111357859" style="zoom:50%;" />

在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，**所以Java程序的编译就是半独立的实现**。

Javac编译器输出的字节码指令流，是一种**基于栈的指令集架构（Instruction SetArchitecture，ISA）**，字节码指令流里面的指令**大部分**都是零地址指令，它们依赖操作数栈进行工作。

**<u>基于栈的解释器执行过程</u>**：实际情况会和上面描述的概念模型差距非常大，差距产生的根本原因是虚拟机中解析器和即时编译器都会对输入的字节码进行**优化**，即使解释器中也不是按照字节码指令去逐条执行的。例如在HotSpot虚拟机中，就有很多以“fast_”开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，即时编译器的优化手段则更是花样繁多。



### 第九章：类加载及执行 子系统的案例与实战

用户能直接参与，通过程序进行操作的，主要是**字节码生成**与**类加载器**这两部分的功能。

#### 9.2 案例分析

**<u>Tomcat：正统的类加载器架构</u>**

主流的Java Web服务器都实现了自己定义的类加载器，而且一般还都不止一个。因为他们需要解决如下的这些问题：

1. 部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离。
2. 部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。
3. 服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。服务器所使用的类库应该与应用程序的类库互相独立。
4. 支持JSP生成类的热替换。

**提供好几个有着不同含义的ClassPath路径供用户存放第三方类库。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。**

在Tomcat目录结构中，可以设置4组目录放置Java类库，每一组都有独立的含义。为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现：

+ 放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用——Common类加载器
+ 放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见——Catalina类加载器（也称为Server类加载器）
+ 放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见——Shared类加载器
+ 放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见——Webapp类加载器。其中WebApp类加载器和JSP类加载器通常还会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个JasperLoader类加载器。



<img src="/Users/chengleiyi/Library/Application Support/typora-user-images/image-20200411142246660.png" alt="image-20200411142246660" style="zoom:43%;" />

**<u>OSGi灵活的类加载器架构</u>**

OSGi（Open Service Gateway Initiative）是OSGi联盟（OSGi Alliance）制订的一个基于Java语言的**动态模块化规范**（在JDK 9引入的JPMS是静态的模块系统）。目的是使服务提供商通过住宅网关为各种家用智能设备提供服务。

OSGi中的每个模块（称为Bundle）与普通的Java类库区别并不太大，两者一般都以JAR格式进行封装，并且内部存储的都是Java的Package和Class。但是一个Bundle可以声明它所依赖的Package（通过Import-Package描述），也可以声明它允许导出发布的Package（通过Export-Package描述）。在OSGi里面，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖，而且类库的可见性能得到非常精确的控制，一个模块里只有被Export过的Package才可能被外界访问，其他的Package和Class将会被隐藏起来。

**<u>字节码生成技术：动态代理的实现</u>**

动态代理中所说的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的，它的优势不在于**省去了编写代理类那一点编码工作量**，而是**实现了可以在原始类和接口还未知的时候**，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。



### 第十章：前端编译和与优化

Java中**即时编译器**在**运行期**的优化过程，支撑了程序执行效率的不断提升；而**前端编译器**在**编译期**的优化过程，则是支撑着程序员的编码效率和语言使用者的幸福感的提高。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者Java虚拟机的底层改进来支持。

+ 前端编译器（把*.java文件转变成*.class文件）：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）
+ 即时编译器（运行期把字节码转变成本地机器码）：HotSpot虚拟机的C1、C2编译器，Graal编译器
+ 提前编译器（直接把程序编译成与目标机器指令集相关的二进制代码）：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET

#### 10.2 javac编译器

一个由Java语言编写的程序。源码在JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac中。

从Javac代码的总体结构来看，**编译过程大致可以分为1个准备过程和3个处理过程**：

1. **准备**：初始化插入式注解处理器。
2. **解析与填充符号表**：
   + **词法、语法分析**。词法分析：将源代码的字符流转变为标记集合，由com.sun.tools.javac.parser. Scanner类来实现；语法分析：构造出抽象语法树（Abstract Syntax Tree，AST），抽象语法树中的每一个节点都代表着程序代码中的一个语法结构，由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树是以com.sun.tools.javac.tree.JCTree类表示的。
   + **填充符号表**。产生符号地址和符号信息，符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构。符号表中所登记的信息在编译的不同阶段都要被用到。

3. **插入式注解处理器的注解处理**：插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许**读取、修改、添加抽象语法树中的任意元素**。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止。
4. **语义分析与字节码生成**，包括：
   + 标注检查。对语法的静态信息进行检查：变量声明、数据类型匹配、常量折叠代码优化。
   + 数据流及控制流分析。对程序动态运行过程进行检查。
   + 解语法糖。将简化代码编写的语法糖还原为原有的形式。
   + 字节码生成。将前面各个步骤所生成的信息转化成字节码，还进行了少量的代码添加和转换工作。



#### 10.3语法糖

**<u>泛型</u>**

泛型的本质是参数化类型（Parameterized Type）或者参数化多态（ParametricPolymorphism）的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。这极大地增强了编程语言的类型系统及抽象能力。

Java选择的泛型实现方式叫作**“类型擦除式泛型”（Type Erasure Generics）**，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList\<int>与ArrayList\<String>其实是同一个类型。

“裸类型”（Raw Type）的概念，裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type）。

其他：

泛型、自动装箱、自动拆箱、遍历循环、变长参数、条件编译、内部类、枚举类、断言语句、数值字面量、对枚举和字符串的switch支持、try语句中定义和关闭资源（这3个从JDK 7开始支持）、Lambda表达式（从JDK8开始支持，Lambda不能算是单纯的语法糖，但在前端编译器中做了大量的转换工作）。



### 第十一章：后端编译与优化

#### 11.2 即时编译器

Java程序最初都是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为**“热点代码”（Hot Spot Code）**，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码**编译成本地机器码**，并以各种手段尽可能地进行代码优化，**运行时完成这个任务的后端编译器被称为即时编译器**。





### 第十二章：Java内存模型与线程

并发处理的广泛应用是**Amdahl定律**代替摩尔定律[插图]成为计算机性能发展源动力的根本原因，也是人类压榨计算机运算能力的最有力武器。

amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力

摩尔定律用于描述处理器晶体管数量与运行效率之间的发展关系

多任务处理：





### 第十三章：线程安全与锁优化

#### 13.2 线程安全



#### 13.3 锁优化

锁优化技术：如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等，这些技术都是为了在线程之间**更高效地共享数据及解决竞争问题，从而提高程序的执行效率。**

**<u>自旋锁与自适应自旋</u>**

让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间（前一个继续执行），看看持有锁的线程是否很快就会释放锁（因为执行时间往往很短）。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。

**<u>锁消除</u>**

虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁（很多锁都不是程序员写的，而是编译的时候产生的）进行消除。

锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。

**<u>锁粗化</u>**

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

**<u>轻量级锁</u>**













### 面试题



**Java的虚拟机的面试内容主要包括三部分：GC、类加载机制，以及内存。**

　　一个**GC部分简单的连环炮。**
面试官可以先问你什么时候一个对象会被GC？
　　接着继续问你为什么要在这种时候对象才会被GC？
　　接着继续问你GC策略都有哪些分类？
　　你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？
　　你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？
　　你如果选出来了，继续问你，为什么要选择这个策略？

**下面是关于类加载机制的简单连环炮。**
首先肯定是先问你Java的类加载器都有哪些？
　　回答了这些以后，可能会问你每个类加载器都加载哪些类？
　　说完以后，可能会问你这些类加载之间的父子关系是怎样的？
　　你在回答的时候可能会提到双亲委派模型，那么可以继续问你什么是双亲委派模型？
　　你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？
　　你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？

**再来一个关于内存的连环炮。**
首先肯定就是问你JVM内存分为哪几部分，这些部分分别都存储哪些数据？
　　然后继续问你一个对象从创建到销毁都是怎么在这些部分里存活和转移的？
　　接着可能会问你，内存的哪些部分会参与GC的回收？
　　完事以后，可能还会问你Java的内存模型是怎么设计的？
　　你回答了以后，还会继续问你为什么要这么设计？
　　问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？
　　你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。



1.jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等
2.你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms
3.当出现了内存溢出，你怎么排错
4.JVM内存模型的相关知识了解多少
5.简单说说你了解的类加载器
6.JAVA的反射机制

