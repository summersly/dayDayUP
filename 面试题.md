### 剑指offer

#### 输入输出

```java
import java.util.Scanner;
public void Main{
  public static void main(String[] args){
    Scanner in = new Scanner(System.in);
    while(in.hasNextInt()){
      int a = in.nextInt();
      int b = in.nextInt();
    }
    String str = sc.nextLine();
    String[] strings = str.split(" ");
    //转为整数数组
    int[] ints = new int[strings.length];
    for (int i = 0; i < strings.length; i++) {
       ints[i] = Integer.parseInt(strings[i]);
    }
    int k = sc.nextInt();
  }
}
```



#### T3 数组中的重复数字

1. 先排序（nlogn），再从头到尾扫描（n）；

   ```java
   Arrays.sort(nums);
   for (int i = 1; i < nums.length; i++) {
       if (nums[i] == nums[i-1]) {
           return nums[i];
       }
   }
   
   return -1;
   ```

2. 哈希表存储（n），空间（n）；

   ```java
   Set<Integer> seen = new HashSet<Integer>();
   for (int num : nums) {
       if (seen.contains(num)) {
           return num;
       }
       seen.add(num);
   }
   
   return -1;
   ```

3. 边扫描边排序，0-n-1的数字，不重复则会出现在对应的下标位置；时间（n），空间（1）

   ```java
   int i = 0;
   // 只要第i为数字不是i，就一直交换，直到出现重复数字
   while(i < nums.length) {
   	if(nums[i] == i) {
     i++;
     continue;
   	}
   	if(nums[nums[i]] == nums[i]) return nums[i];
   	int tmp = nums[i];
   	nums[i] = nums[tmp];
   	nums[tmp] = tmp;
   }
   return -1; // 边界情况：数组长度0，1或者不包含重复数字的情况
   ```

4. 不修改原数组的情况：二分法查找重复数字，调用countRange得到符合二分区间的数值个数，调用（logn），每次（n），总时间（nlogn），空间（1）

   ```java
   int start = 1, end = nums.length-1;
   while(end>start){
     int mid = (end+start)/2;
     //
     int count = 0;
     for(int i = 0; i < nums.length; i++){
         if(nums[i]>=start && nums[i]<=mid) count++;
     }
     if(count>(mid-start+1)) end = mid;
     else start = mid+1;
   }
   return start;
   ```

5. 快慢指针：先通过快慢指针找到开始循环（即相同数字的地方），然后从头用一个慢指针，找到♻️的进入口。

   ```java
   // 快慢指针
   int kuai = nums[0], man = nums[0];
   do{
       man = nums[man];
       kuai = nums[nums[kuai]];
   } while(kuai!=man);
   int i = nums[0];
   while(i!=man){
       i = nums[i];
       man = nums[man];
   }
   return i;
   ```

   

#### T4 二维数组中的查找

1. 数组有序，从左到右，从上到下递增。从右上角开始检查，逐渐缩小范围：

   + 若右上角大于目标，可以剔除 `列`

   + 若等于目标，返回

   + 若右上角小于目标，可以剔除 `行` 

     ```java
     int i = 0, j = matrix[0].length-1;
     while (i < matrix.length && j >=0){
     	if(matrix[i][j]==target) return true;
     	else if(matrix[i][j]>target) j--;
     	else i++;
     }
     return false;
     ```



#### T5 替换字符串中的内容

从后往前遍历，这样可以减少挪动的次数。类似的还有合并两个数组。



#### T6从尾到头打印链表

在不能改变链表结构的情况下：**栈或者递归**，能用栈就少用递归，因为函数调用层级太多可能会导致溢出。

```java
LinkedList<ListNode> stack = new LinkedList<>();
int count = 0;
while(head != null){
	stack.push(head);
	head = head.next;
	count++;
}
int[] res = new int[count];
int k = 0;
while(!stack.isEmpty()){
	res[k++] = stack.pop().val;
}
return res;
```



#### T7 重建二叉树

```java
// 前序遍历第一个节点就是root，第二个节点是左子树的root，第三个是左子树的左子树的root。。。。。
// 遍历map（n），每个节点new （n），平均情况下递归深度（log2n）
// 空间map的（n）
List<Integer> inorder;
public TreeNode buildTree(int[] preorder, int[] inorder){
  this.preorder = preorder;
  this.inorder = Arrays.asList(inorder);//不好用的 error
  return help(0,inorder.length);
}
// java中的array没有indexOf！！！所以还是用map吧
private TreeNode help (int inStart, int inEnd){
  if(inStart == inEnd) return null;
  int rootIndex = inorder.indexOf(preorder[preIndex]);
  TreeNode root = new TreeNode(preorder[preIndex++]);
  root.left = help(inStart, rootIndex);
  root.right = help(rootIndex+1, inEnd);
  return root;
}
```



#### T8 二叉树的下一个节点

给定一个二叉树和其中的一个节点，求这个节点中序遍历下的下一个节点（左右孩子和父节点已知）

```java
// 已知parent的情况下
public TreeNode getNext(TreeNode root){
  if(root == null) return null;
  if(root.right != null){
    root = root.right;
    while(root.left!=null) root = root.left;
    return root;
  }
  while(root.parent != null){
    if(root == root.parent.left) return root.parent;
    else root = root.parent;
  }
  return null;
}
```



#### T9 用两个栈实现队列

```java
private Stack<Integer> A;
private Stack<Integer> B;
public CQueue() {
    A = new Stack<>();
    B = new Stack<>();
}
public void appendTail(int value){
  A.push(value);
}
public int deleteHead(){
  if(!B.empty()) return B.pop();
  while(!A.empty()) B.push(A.pop());
  if(B.empty()) return -1;
  return B.pop();
}
```



#### T10 斐波那契数列

**二分查找、归并排序、快速排序**

**二维数组搜索路径，适合用回溯（递归），不能用回溯的时候，用栈模拟递归**

**某个问题的最优解，将一个问题划分为多个子问题，用动态规划：先自上而下的写出规划方程，再自下而上的循环实现 -------- 贪婪？？**

```java
// （n）
if(n == 0) return 0;
if(n == 1) return 1;
int one = 0, two = 1;
for(int i = 2; i <=n ; i++){
  int sum = one + two; // 取模：两个数分别取模之后相加再取模 等价于 先相加再取模
  one = two;
  two = sum;
}
return two;
//（logn）
// 太难了要数学的
```

 **查找和排序！**

顺序查找，二分查找，哈希表查找，二叉搜索树查找

插入排序、冒泡排序、归并排序、快速排序的比较！从额外空间消耗、平均时间复杂度、最差时间复杂度三方面来比较。

交换成本高的情况下，可以用选择排序：选择排序的交换次数最少；

插入排序是稳定的，在数组接近有序的情况下使用，表现最优，短数组也可以选择插入排序；



|                  | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 |
| ---------------- | -------------- | -------------- | ---------- |
| 冒泡排序（交换） | $$n^2$$        | $$n^2$$        | 1          |
| 快速排序（交换） | $$nlogn$$      | $$n^2$$        | $$nlogn$$  |
| 插入排序（插入） | $$n^2$$        | $$n^2$$        | 1          |
| 归并排序（二路） | $$nlogn$$      | $$nlogn$$      | n          |

```java
// 冒泡模版 从小到大
private void bubbleSort(int[] nums){
  for(int i = nums.length-1; i >= 1; i--){
    for(int j = 0 ; j < i; j++){
      if(nums[j]>nums[j+1]) swap(nums, j, j+1);
    }
  }
}
// 带标记的冒泡优化
private static void bubbleSort2(int[] nums){
  boolean change = false;
  for(int i = nums.length-1; i >= 1; i--){
      for(int j = 0 ; j < i; j++){
          if(nums[j]>nums[j+1]) {swap(nums, j, j+1); change = true;}
      }
      if(!change) break;
  }
}
// 标记冒泡尾巴的优化
private static void bubbleSort3(int[] nums){
  int i ,j;
  int flag = nums.length-1;
  while(flag>0){
      i = flag;
      flag = 0;
      for(j = 0; j < i; j++){
          if(nums[j]>nums[j+1]) {
              swap(nums, j, j+1); 
              flag = j+1;
          }
      }
  }        
}
```

```java
// 快速排序
private void quickSort(int[] nums, int start, int end){
  if(start = end) return;
  int pivotIndex = partition(nums, start, end);
  if(pivotIndex > start) quickSort(nums, start, pivotIndex-1);
  if(pivotIndex < end) quickSort(nums, pivotIndex+1, end);
}
private int partition(int[] nums, int start, int end){
  int pivot = nums[start];
  int lt = start +1;
  int gt = end;
  while(true){
    while(lt<=end&&nums[lt]<pivot) lt++;
    while(gt>left&&nums[gt]>pivot) gt--;
    if(lt>gt) break;
    swap(nums, lt, gt);
    lt++;
    gt--;
  }
  swap(nums, start, gt);
  return gt;
}
```

```java
// 插入排序
private void insertSort(int[] nums){
  for(int i = 1; j < nums.length; j++){
    int tmp = nums[i];
    int j = i;
    while(j > 0 && nums[j-1] > tmp){
      nums[j] = nums[j-1];
      j--;
    }
    nums[j] = tmp;
  }
}
```

```java
// 归并排序
mergeSort(nums, 0, len - 1);
private void mergeSort(int[] nums, int start, int end){
  int mid = (start+end)>>>1;
  mergeSort(nums, start, mid);
  mergeSort(nums, mid+1, end);
  if(nums[mid] <= nums[mid+1]) return;
  mergeTwo(nums, start, mid, end);
}

private void mergeTwo(int[] nums, int start, int mid, int end){
  int tmp = new int[end-start+1];
  System.arraycopy(nums, start, tmp, start, end-start+1);
  int i = start, j = mid+1;
  for(int k = start; k <= end; k+){
    if(i == mid+1) nums[k] = tmp[j++]; // 数组1 到底了
    else if(j == end+1) nums[k] = tmp[i++];
    else if(tmp[i]<=tmp[j]) nums[k] = tmp[i++];
    else nums[k] = nums[j++];
  }
}
```

```java
// 选择排序

```



#### T11 旋转数组的最小数字

**在有序数组中查找或者统计数字出现的次数，都可以用二分查找**

```java
// 二分查找
// 二分查找场景：寻找一个数，寻找左侧边界，寻找右侧边界
// 初始条件【0,len-1】--》while(left<=right)
// 初始条件【0,len】--> while(left<right)
// 模版 
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意
    while(left <= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; 
        else if (nums[mid] > target)
            right = mid - 1;
    }
    return -1;
}
// 左边界/右边界 初始化[0, len) 左闭右开
// while(left<right) left = mid+1; right = mid 这三个都不变，只改变相等情况下的收敛方向
// 左边界：需要定位到左边，所以相等的时候改变 右界
int binarySearchLeft(int[] nums, int target){
  	int left = 0;
  	int right = nums.length;
  	while(left<right){
      int mid = (left + end)>>>1;
      if(nums[mid] < target) left = mid + 1;
      else right = mid;
    }
    return left; //出循环的时候，left和right相等，但是左闭右开所以搜索区间内没有数据
  // 这个数不存在的时候，左边界返回的是第一个大于target的位置
}
// 右边界：需要定位到右边，所以相等的时候改变 左界
int binarySearchRight(int[] nums, int target){
  	int left = 0;
  	int right = nums.length;
  	while(left<right){
      int mid = (left + end)>>>1;
      if(nums[mid] <= target) left = mid + 1;
      else right = mid;
    }
    return left; // 此时返回的是第一个大于target的位置（存在或者不存在都一样）
  // 如果需要返回确切的右边界，则 return left-1
 
 // 综上，如果要同时查找左右边界，可以查找target的右边界（值为target+1）和target-1的右边界（值为target），两个直接相减就是target的数量
}
```

```java
int i = 0, j = numbers.length - 1;
while (i < j) { 
  //这里不用i<=j ，是因为最小元素必存在，最后这一个数值，不需要再比较了，可以直接退出循环
  int m = (i + j) / 2;
  if (numbers[m] > numbers[j]) i = m + 1;
  else if (numbers[m] < numbers[j]) j = m;
  else j--; 
  // j--可能会丢失旋转点，111231，但是去掉这个旋转点后剩下的数列中仍有和它相等的值存在，返回的答案还是一样的
}
return numbers[i];
```



#### T12 矩阵中的路径

**回溯法：暴力的优化，一个问题可以分步骤求解的时候，适用该方法；例如，在二维矩阵上寻找路径**

```java
public boolean exist(char[][] board, String word) {
  if(board.length<=0||board[0].length<=0) return false;
  if(word.length()<=0) return true;
  char[] words = word.toCharArray();
  for(int i=0; i<board.length; i++){
    for(int j=0; j<board[0].length; j++){
      if(dfs()) return true;
    }
  }
  return false;
}
private boolean dfs(char[][] board, char[] word, int i, int j, int k){
  if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j] != word[k]) 
    return false;
  if(k == word.length-1) return true;
  // 已经访问过的地方标记为‘#’ 表示不能访问第二次
  char tmp = board[i][j];
  board[i][j] = '#';
  boolean res = dfs(board, word, i+1, j, k+1) || dfs(board, word, i-1, j, k+1) || dfs(board, word, i, j+1, k+1)|| dfs(board, word, i, j-1, k+1);
  board[i][j] = tmp;
  return res;
}
```

#### T13 机器人的运动范围

```java
// DFS
private boolean[][] visited;
public int movingCount(int m, int n, int k) {
  this.visited = new boolean[m][n];
  return dfs(0,0,m,n,k);
}
private int dfs(int i, int j, int m, int n, int k){
  // 只向右向下搜索，i、j不会小于0 ,下方和右方有重叠区域，所以需要visited来记录全局的访问情况
  if(i>=m || j>=n || sum(i)+sum(j) > k || visited[i][j]) return 0;
  visited[i][j] = true;
  return 1 + dfs(i+1,j,m,n,k) + dfs(i,j+1,m,n,k); 
}
// BFS
public int movingCount(int m, int n, int k) {
  LinkedList<int[]> queue = new LinkedList<>();
  int res = 0;
  boolean visited = new boolean[m][n];
  queue.offerLast(new int[]{0,0});
  while(!queue.isEmpty()){
    int[] cur = queue.pollFirst();
    // 
  }
}
// sum 这里可以找数学规律来减少运算量
private int sum(n){
  int sum = 0;
  while(n>0){
    sum += n%10;
    n /= 10;
  }
  return sum;
}
```



####T14 剪绳子

**动态规划与贪婪算法：有点类似，但是贪婪算法是需要通过数学推导得到最优的方式，然后一直用这种最优的状态一步步推进；动态规划需要知道基础值。**

```java
// 贪婪/数学
// 以相同的长度分为多段，此时乘积最大，当每段为3（x=e，2.7）时取到最大
// 因此n % 3

//动态规划

```

#### T15 二进制中1的个数

```java
private int numberOf(int n){
  int count = 0;
  while(n){
    ++count;
    n = n&(n-1);
  }
  return count;
}
```



**1. 基本功能；2. 边界值； 3. 不合规范的非法输入；！！！！返回值、全局变量和异常**

#### T16 数值的整数次方

```java
// 指数 正 负 0
// 底数 0 非零
// 位与运算代替求余数判断奇偶；右移运算代替除法
public double myPow(double x, int n) {
  if(x == 0) return 0;
  long N = (long) n;
  if(N<0){
    x = 1/x;
    N = -N;
  }
  double res = 1.0;
  while(N>0){
    if((N&1)==1) res *= x;
    x *= x;
    N >>= 1;
  }
}
```



####T17 打印从1最大的n位数

**大数问题！！！：没有规定n的范围，所以可能long都不够用。一般会用字符串或者数组来表示大数！**

```java
// 用字符串表示，每一个char代表一个数位
public void printNumbers(int n) {
  StringBuilder sb = new StringBuilder();
  for(int i = 0; i<n; i++){
    sb.append("0");
  }
  while(!increaseNum(sb)){
    printStringNumber(str);
  }
}
private boolean increaseNum(StringBuilder sb){
  boolean overFlow = false;
  for(int i = sb.length()-1 ; i >=0 ; i--){
    char s = (char) (sb.charAt(i) + 1);
    if(s > '9'){
      sb.replace(i, i+1, '0');
  		if(i == 0) overFlow = true;    
    } else {
      sb.replace(i, i+1, s);
      break;
    }
  }
  return overFlow;
}
private void printStringNumber(StringBuilder sb){
  int i = 0;
  while(i < nums.length && sb.charAt(i) == '0') i++;
  System.out.println(sb.substring(i).toString());
}
```



#### T18 删除链表节点

**leetcode中的待删除节点是用int来表示的，所以只能从头遍历来定位它；而原题是用ListNode来表示的，可以分成三种情况来处理：待删除节点不是头节点也不是尾节点，将next的val复制到当前节点，去掉next；待删除节点是头节点；待删除节点是尾节点，需要遍历。整体时间复杂度O(1）。**



#### T19































### 面试题

#### 字节跳动

1. 先自我介绍
2. 线程池的线程数怎么确定？
3. 如果是IO操作为主怎么确定？
4. 如果计算型操作又怎么确定？
5. Redis熟悉么，了解哪些数据结构?
6. 跳表的查询过程是怎么样的，查询和插入的时间复杂度?
7. 红黑树了解么，时间复杂度?
8. 既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树
9. 说下Dubbo的原理?
10. CAS了解么？
11. 那我们做一道题吧，数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数
12. 先说下你的思路
13. 下一个奇数？怎么找？
14. 有思路么？
15. 你这样时间复杂度有点高，如果要求O(N)要怎么做
16. 时间差不多了，先到这吧。你有什么想问我的？
17. 你对服务治理怎么理解的？
18. 项目中的限流怎么实现的？具体怎么实现的？
19. 如果突然很多线程同时请求令牌，有什么问题？怎么解决呢？如果不用消息队列怎么解决？
20. 分布式追踪的上下文是怎么存储和传递的？
21. Dubbo的RpcContext是怎么传递的？
22. 你说的内存泄漏具体是怎么产生的？
23. 线程池的线程是不是必须手动remove才可以回收value？
24. 那你说的内存泄漏是指主线程还是线程池？
25. 可是主线程不是都退出了，引用的对象不应该会主动回收么？
26. 那你说下SpringMVC不同用户登录的信息怎么保证线程安全的？
27. 这个直接用ThreadLocal不就可以么，你见过SpringMVC有锁实现的代码么？
28. 我们聊聊mysql吧，说下索引结构
29. 为什么使用B+树？
30. 什么是索引覆盖？
31. Java为什么要设计双亲委派模型？
32. 什么时候需要自定义类加载器？
33. 手写一个对象池



#### 阿里巴巴

第一道题：蚂蚁森林n个小动物，1~n,小动物编号越小能力越强，现在筛选国王，每个小动物都会崇拜别的小动物或者自己，但只会崇拜比自己能力强的小动物。问每个人最多可以获得多少票。

图的路径搜索，但是不会就没做，后来上网查了floyd和Dijkstra(迪杰斯特拉)算法都可以破解，但floyd可能会超时

1. 单机部署项目，问题很多，版本迭代就要kill进程，有什么问题？你有想过怎么解决好点吗？

   后面问了问朋友，生产直接kill是不行的，强制杀死容易出问题，Kill这个操作不是生产操作，最简单就是布完包重启tomcat。就是取代kill操作啊，但还是以前的部署操作。（唉，我确实菜，项目经验确实不够）

2. 你的项目很慢，你应该做什么排查？例如查询一个数据很慢，你会怎么做？

   我那时候一开始就说对项目的优化嘛，我直接就说建立索引什么的，我以为他会要我说说索引原理什么嘛，结果她问我怎么确定就是数据库的问题，不是其他的问题，要怎么排查

   我确实不知道，后面补充一下：

   可以从应用，数据库，和运行环境分析；可以考虑用户网络环境，然后是应用中的调用链路是否存在问题（循环调用？外部依赖过多？），然后是数据库。有应用监控系统最好不过了，可以比较具体的排查。

   数据库的原因也很多，sql问题，也有可能是数据库本身延时高。

   Linux查看一下进程也需要，查看进程排查应用所在环境因素（其他进程对该应用程序的影响）

   而且索引也不是绝对的优化方法，可能本身的sql是否可以优化，如果连表过多，是否可以拆解到应用层做，或是压根表设计不合理

3. 类的加载？——》

   双亲委派的过程？——》

   还问为什么要双亲委派？

   补充：
   确实是安全，如果没有这种机制，编写了一个java.lang.Object的同名类并放在ClassPath中，程序一跑，多个Object继续加载，就不能保证object的唯一性。

   因此，解决就说通过类加载机制。底层是代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。

4. 三个工厂模式，有什么区别

   答案：

   三个工厂模式，各有千秋

   从简单工厂模式——》工厂方法模式，解决了对产品的拓展不符合OCT原则的问题

   从工厂方法模式——》抽象工厂模式，解决了一个过程只能生产一个产品的问题

   但是反而多了一个问题，就是又产生了部分不符合OCT原则的问题，对工厂的拓展符合OCT，但是没错要拓展一个产品，就要修改一次工厂里面的方法

5. 高并发的concurrenthashmap

   推荐使用，
   在jdk8之前是使用分段加锁的一个方式，分成16个桶，每次只加锁其中一个桶，而在jdk8又加入了红黑树和CAS算法来实现。
   每次只会锁目前一个segment，用synchronized+CAS，效率更高了，并发度更高。

   问题：concurrenthashmap，有一个线程进入这一个桶，进行put方法，他还能再进入吗？

   妈呀，我竟然说不可以，前面都采用synchronized了，synchronized是可重入锁啊！！！后面纠正过来了，但是。。

6. spring容器启动过程

   spring我配置文件在哪里读取？


